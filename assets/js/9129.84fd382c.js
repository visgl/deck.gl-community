"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[9129],{10201:(t,i,n)=>{n.d(i,{FD:()=>o,FK:()=>e.FK,Y:()=>o});var e=n(50172);var s=0;Array.isArray;function o(t,i,n,o,r,a){i||(i={});var l,c,d=i;if("ref"in d)for(c in d={},i)"ref"==c?l=i[c]:d[c]=i[c];var u={type:t,props:d,key:n,ref:l,__k:null,__:null,__b:0,__e:null,__c:null,constructor:void 0,__v:--s,__i:-1,__u:0,__source:r,__self:a};if("function"==typeof t&&(l=t.defaultProps))for(c in l)void 0===d[c]&&(d[c]=l[c]);return e.fF.vnode&&e.fF.vnode(u),u}},12228:(t,i,n)=>{n.d(i,{A:()=>e});const e="// Main shaders\n\nstruct ScatterplotUniforms {\n  radiusScale: f32,\n  radiusMinPixels: f32,\n  radiusMaxPixels: f32,\n  lineWidthScale: f32,\n  lineWidthMinPixels: f32,\n  lineWidthMaxPixels: f32,\n  stroked: f32,\n  filled: i32,\n  antialiasing: i32,\n  billboard: i32,\n  radiusUnits: i32,\n  lineWidthUnits: i32,\n};\n\nstruct ConstantAttributeUniforms {\n instancePositions: vec3<f32>,\n instancePositions64Low: vec3<f32>,\n instanceRadius: f32,\n instanceLineWidths: f32,\n instanceFillColors: vec4<f32>,\n instanceLineColors: vec4<f32>,\n instancePickingColors: vec3<f32>,\n\n instancePositionsConstant: i32,\n instancePositions64LowConstant: i32,\n instanceRadiusConstant: i32,\n instanceLineWidthsConstant: i32,\n instanceFillColorsConstant: i32,\n instanceLineColorsConstant: i32,\n instancePickingColorsConstant: i32\n};\n\n@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;\n\nstruct ConstantAttributes {\n  instancePositions: vec3<f32>,\n  instancePositions64Low: vec3<f32>,\n  instanceRadius: f32,\n  instanceLineWidths: f32,\n  instanceFillColors: vec4<f32>,\n  instanceLineColors: vec4<f32>,\n  instancePickingColors: vec3<f32>\n};\n\nconst constants = ConstantAttributes(\n  vec3<f32>(0.0),\n  vec3<f32>(0.0),\n  0.0,\n  0.0,\n  vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  vec3<f32>(0.0)\n);\n\nstruct Attributes {\n  @builtin(instance_index) instanceIndex : u32,\n  @builtin(vertex_index) vertexIndex : u32,\n  @location(0) positions: vec3<f32>,\n  @location(1) instancePositions: vec3<f32>,\n  @location(2) instancePositions64Low: vec3<f32>,\n  @location(3) instanceRadius: f32,\n  @location(4) instanceLineWidths: f32,\n  @location(5) instanceFillColors: vec4<f32>,\n  @location(6) instanceLineColors: vec4<f32>,\n  @location(7) instancePickingColors: vec3<f32>\n};\n\nstruct Varyings {\n  @builtin(position) position: vec4<f32>,\n  @location(0) vFillColor: vec4<f32>,\n  @location(1) vLineColor: vec4<f32>,\n  @location(2) unitPosition: vec2<f32>,\n  @location(3) innerUnitRadius: f32,\n  @location(4) outerRadiusPixels: f32,\n};\n\n@vertex\nfn vertexMain(attributes: Attributes) -> Varyings {\n  var varyings: Varyings;\n\n  // Draw an inline geometry constant array clip space triangle to verify that rendering works.\n  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));\n  // if (attributes.instanceIndex == 0) {\n  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);\n  //   return varyings;\n  // }\n\n  // var geometry: Geometry;\n  // geometry.worldPosition = instancePositions;\n\n  // Multiply out radius and clamp to limits\n  varyings.outerRadiusPixels = clamp(\n    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),\n    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels\n  );\n\n  // Multiply out line width and clamp to limits\n  let lineWidthPixels = clamp(\n    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),\n    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;\n  // Expand geometry to accommodate edge smoothing\n  let edgePadding = select(\n    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,\n    1.0,\n    scatterplot.antialiasing != 0\n  );\n\n  // position on the containing square in [-1, 1] space\n  varyings.unitPosition = edgePadding * attributes.positions.xy;\n  geometry.uv = varyings.unitPosition;\n  geometry.pickingColor = attributes.instancePickingColors;\n\n  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;\n\n  if (scatterplot.billboard != 0) {\n    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);\n    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);\n    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;\n    // DECKGL_FILTER_SIZE(offset, geometry);\n    let clipPixels = project_pixel_size_to_clipspace(offset.xy);\n    varyings.position.x = clipPixels.x;\n    varyings.position.y = clipPixels.y;\n  } else {\n    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);\n    // DECKGL_FILTER_SIZE(offset, geometry);\n    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);\n    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);\n  }\n\n  // Apply opacity to instance color, or return instance picking color\n  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * color.opacity);\n  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);\n  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * color.opacity);\n  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);\n\n  return varyings;\n}\n\n@fragment\nfn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {\n  // var geometry: Geometry;\n  // geometry.uv = unitPosition;\n\n  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;\n  let inCircle = select(\n    smoothedge(distToCenter, varyings.outerRadiusPixels),\n    step(distToCenter, varyings.outerRadiusPixels),\n    scatterplot.antialiasing != 0\n  );\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  var fragColor: vec4<f32>;\n\n  if (scatterplot.stroked != 0) {\n    let isLine = select(\n      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),\n      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),\n      scatterplot.antialiasing != 0\n    );\n\n    if (scatterplot.filled != 0) {\n      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);\n    }\n  } else if (scatterplot.filled == 0) {\n    discard;\n  } else {\n    fragColor = varyings.vFillColor;\n  }\n\n  fragColor.a *= inCircle;\n  // DECKGL_FILTER_COLOR(fragColor, geometry);\n\n  // Apply premultiplied alpha as required by transparent canvas\n  fragColor = deckgl_premultiplied_alpha(fragColor);\n\n  return fragColor;\n  // return vec4<f32>(0, 0, 1, 1);\n}\n"},28141:(t,i,n)=>{n.d(i,{A:()=>s});const e=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class s{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[i,n]=new Uint8Array(t,0,2);if(219!==i)throw new Error("Data does not appear to be in a KDBush format.");const o=n>>4;if(1!==o)throw new Error(`Got v${o} data when expected v1.`);const r=e[15&n];if(!r)throw new Error("Unrecognized array type.");const[a]=new Uint16Array(t,2,1),[l]=new Uint32Array(t,4,1);return new s(l,a,r,t)}constructor(t,i=64,n=Float64Array,s){if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+i,2),65535),this.ArrayType=n,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const o=e.indexOf(this.ArrayType),r=2*t*this.ArrayType.BYTES_PER_ELEMENT,a=t*this.IndexArrayType.BYTES_PER_ELEMENT,l=(8-a%8)%8;if(o<0)throw new Error(`Unexpected typed array class: ${n}.`);s&&s instanceof ArrayBuffer?(this.data=s,this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+a+l,2*t),this._pos=2*t,this._finished=!0):(this.data=new ArrayBuffer(8+r+a+l),this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+a+l,2*t),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+o]),new Uint16Array(this.data,2,1)[0]=i,new Uint32Array(this.data,4,1)[0]=t)}add(t,i){const n=this._pos>>1;return this.ids[n]=n,this.coords[this._pos++]=t,this.coords[this._pos++]=i,n}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return o(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,i,n,e){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:s,coords:o,nodeSize:r}=this,a=[0,s.length-1,0],l=[];for(;a.length;){const c=a.pop()||0,d=a.pop()||0,u=a.pop()||0;if(d-u<=r){for(let r=u;r<=d;r++){const a=o[2*r],c=o[2*r+1];a>=t&&a<=n&&c>=i&&c<=e&&l.push(s[r])}continue}const p=u+d>>1,h=o[2*p],f=o[2*p+1];h>=t&&h<=n&&f>=i&&f<=e&&l.push(s[p]),(0===c?t<=h:i<=f)&&(a.push(u),a.push(p-1),a.push(1-c)),(0===c?n>=h:e>=f)&&(a.push(p+1),a.push(d),a.push(1-c))}return l}within(t,i,n){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:e,coords:s,nodeSize:o}=this,r=[0,e.length-1,0],a=[],l=n*n;for(;r.length;){const d=r.pop()||0,u=r.pop()||0,p=r.pop()||0;if(u-p<=o){for(let n=p;n<=u;n++)c(s[2*n],s[2*n+1],t,i)<=l&&a.push(e[n]);continue}const h=p+u>>1,f=s[2*h],g=s[2*h+1];c(f,g,t,i)<=l&&a.push(e[h]),(0===d?t-n<=f:i-n<=g)&&(r.push(p),r.push(h-1),r.push(1-d)),(0===d?t+n>=f:i+n>=g)&&(r.push(h+1),r.push(u),r.push(1-d))}return a}}function o(t,i,n,e,s,a){if(s-e<=n)return;const l=e+s>>1;r(t,i,l,e,s,a),o(t,i,n,e,l-1,1-a),o(t,i,n,l+1,s,1-a)}function r(t,i,n,e,s,o){for(;s>e;){if(s-e>600){const a=s-e+1,l=n-e+1,c=Math.log(a),d=.5*Math.exp(2*c/3),u=.5*Math.sqrt(c*d*(a-d)/a)*(l-a/2<0?-1:1);r(t,i,n,Math.max(e,Math.floor(n-l*d/a+u)),Math.min(s,Math.floor(n+(a-l)*d/a+u)),o)}const l=i[2*n+o];let c=e,d=s;for(a(t,i,e,n),i[2*s+o]>l&&a(t,i,e,s);c<d;){for(a(t,i,c,d),c++,d--;i[2*c+o]<l;)c++;for(;i[2*d+o]>l;)d--}i[2*e+o]===l?a(t,i,e,d):(d++,a(t,i,d,s)),d<=n&&(e=d+1),n<=d&&(s=d-1)}}function a(t,i,n,e){l(t,n,e),l(i,2*n,2*e),l(i,2*n+1,2*e+1)}function l(t,i,n){const e=t[i];t[i]=t[n],t[n]=e}function c(t,i,n,e){const s=t-n,o=i-e;return s*s+o*o}},42124:(t,i,n)=>{n.d(i,{A:()=>e});const e="#version 300 es\n#define SHADER_NAME scatterplot-layer-fragment-shader\nprecision highp float;\nin vec4 vFillColor;\nin vec4 vLineColor;\nin vec2 unitPosition;\nin float innerUnitRadius;\nin float outerRadiusPixels;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = unitPosition;\nfloat distToCenter = length(unitPosition) * outerRadiusPixels;\nfloat inCircle = scatterplot.antialiasing ?\nsmoothedge(distToCenter, outerRadiusPixels) :\nstep(distToCenter, outerRadiusPixels);\nif (inCircle == 0.0) {\ndiscard;\n}\nif (scatterplot.stroked > 0.5) {\nfloat isLine = scatterplot.antialiasing ?\nsmoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\nstep(innerUnitRadius * outerRadiusPixels, distToCenter);\nif (scatterplot.filled > 0.5) {\nfragColor = mix(vFillColor, vLineColor, isLine);\n} else {\nif (isLine == 0.0) {\ndiscard;\n}\nfragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n}\n} else if (scatterplot.filled < 0.5) {\ndiscard;\n} else {\nfragColor = vFillColor;\n}\nfragColor.a *= inCircle;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n"},48839:(t,i,n)=>{n.d(i,{A:()=>a});var e=n(28141);const s={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},o=Math.fround||(r=new Float32Array(1),t=>(r[0]=+t,r[0]));var r;class a{constructor(t){this.options=Object.assign(Object.create(s),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){const{log:i,minZoom:n,maxZoom:e}=this.options;i&&console.time("total time");const s=`prepare ${t.length} points`;i&&console.time(s),this.points=t;const r=[];for(let l=0;l<t.length;l++){const i=t[l];if(!i.geometry)continue;const[n,e]=i.geometry.coordinates,s=o(d(n)),a=o(u(e));r.push(s,a,1/0,l,-1,1),this.options.reduce&&r.push(0)}let a=this.trees[e+1]=this._createTree(r);i&&console.timeEnd(s);for(let o=e;o>=n;o--){const t=+Date.now();a=this.trees[o]=this._createTree(this._cluster(a,o)),i&&console.log("z%d: %d clusters in %dms",o,a.numItems,+Date.now()-t)}return i&&console.timeEnd("total time"),this}getClusters(t,i){let n=((t[0]+180)%360+360)%360-180;const e=Math.max(-90,Math.min(90,t[1]));let s=180===t[2]?180:((t[2]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)n=-180,s=180;else if(n>s){const t=this.getClusters([n,e,180,o],i),r=this.getClusters([-180,e,s,o],i);return t.concat(r)}const r=this.trees[this._limitZoom(i)],a=r.range(d(n),u(o),d(s),u(e)),c=r.data,p=[];for(const d of a){const t=this.stride*d;p.push(c[t+5]>1?l(c,t,this.clusterProps):this.points[c[t+3]])}return p}getChildren(t){const i=this._getOriginId(t),n=this._getOriginZoom(t),e="No cluster with the specified id.",s=this.trees[n];if(!s)throw new Error(e);const o=s.data;if(i*this.stride>=o.length)throw new Error(e);const r=this.options.radius/(this.options.extent*Math.pow(2,n-1)),a=o[i*this.stride],c=o[i*this.stride+1],d=s.within(a,c,r),u=[];for(const p of d){const i=p*this.stride;o[i+4]===t&&u.push(o[i+5]>1?l(o,i,this.clusterProps):this.points[o[i+3]])}if(0===u.length)throw new Error(e);return u}getLeaves(t,i,n){i=i||10,n=n||0;const e=[];return this._appendLeaves(e,t,i,n,0),e}getTile(t,i,n){const e=this.trees[this._limitZoom(t)],s=Math.pow(2,t),{extent:o,radius:r}=this.options,a=r/o,l=(n-a)/s,c=(n+1+a)/s,d={features:[]};return this._addTileFeatures(e.range((i-a)/s,l,(i+1+a)/s,c),e.data,i,n,s,d),0===i&&this._addTileFeatures(e.range(1-a/s,l,1,c),e.data,s,n,s,d),i===s-1&&this._addTileFeatures(e.range(0,l,a/s,c),e.data,-1,n,s,d),d.features.length?d:null}getClusterExpansionZoom(t){let i=this._getOriginZoom(t)-1;for(;i<=this.options.maxZoom;){const n=this.getChildren(t);if(i++,1!==n.length)break;t=n[0].properties.cluster_id}return i}_appendLeaves(t,i,n,e,s){const o=this.getChildren(i);for(const r of o){const i=r.properties;if(i&&i.cluster?s+i.point_count<=e?s+=i.point_count:s=this._appendLeaves(t,i.cluster_id,n,e,s):s<e?s++:t.push(r),t.length===n)break}return s}_createTree(t){const i=new e.A(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let n=0;n<t.length;n+=this.stride)i.add(t[n],t[n+1]);return i.finish(),i.data=t,i}_addTileFeatures(t,i,n,e,s,o){for(const r of t){const t=r*this.stride,a=i[t+5]>1;let l,p,h;if(a)l=c(i,t,this.clusterProps),p=i[t],h=i[t+1];else{const n=this.points[i[t+3]];l=n.properties;const[e,s]=n.geometry.coordinates;p=d(e),h=u(s)}const f={type:1,geometry:[[Math.round(this.options.extent*(p*s-n)),Math.round(this.options.extent*(h*s-e))]],tags:l};let g;g=a||this.options.generateId?i[t+3]:this.points[i[t+3]].id,void 0!==g&&(f.id=g),o.features.push(f)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,i){const{radius:n,extent:e,reduce:s,minPoints:o}=this.options,r=n/(e*Math.pow(2,i)),a=t.data,l=[],c=this.stride;for(let d=0;d<a.length;d+=c){if(a[d+2]<=i)continue;a[d+2]=i;const n=a[d],e=a[d+1],u=t.within(a[d],a[d+1],r),p=a[d+5];let h=p;for(const t of u){const n=t*c;a[n+2]>i&&(h+=a[n+5])}if(h>p&&h>=o){let t,o=n*p,r=e*p,f=-1;const g=(d/c<<5)+(i+1)+this.points.length;for(const n of u){const e=n*c;if(a[e+2]<=i)continue;a[e+2]=i;const l=a[e+5];o+=a[e]*l,r+=a[e+1]*l,a[e+4]=g,s&&(t||(t=this._map(a,d,!0),f=this.clusterProps.length,this.clusterProps.push(t)),s(t,this._map(a,e)))}a[d+4]=g,l.push(o/h,r/h,1/0,g,-1,h),s&&l.push(f)}else{for(let t=0;t<c;t++)l.push(a[d+t]);if(h>1)for(const t of u){const n=t*c;if(!(a[n+2]<=i)){a[n+2]=i;for(let t=0;t<c;t++)l.push(a[n+t])}}}}return l}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,i,n){if(t[i+5]>1){const e=this.clusterProps[t[i+6]];return n?Object.assign({},e):e}const e=this.points[t[i+3]].properties,s=this.options.map(e);return n&&s===e?Object.assign({},s):s}}function l(t,i,n){return{type:"Feature",id:t[i+3],properties:c(t,i,n),geometry:{type:"Point",coordinates:[(e=t[i],360*(e-.5)),p(t[i+1])]}};var e}function c(t,i,n){const e=t[i+5],s=e>=1e4?`${Math.round(e/1e3)}k`:e>=1e3?Math.round(e/100)/10+"k":e,o=t[i+6],r=-1===o?{}:Object.assign({},n[o]);return Object.assign(r,{cluster:!0,cluster_id:t[i+3],point_count:e,point_count_abbreviated:s})}function d(t){return t/360+.5}function u(t){const i=Math.sin(t*Math.PI/180),n=.5-.25*Math.log((1+i)/(1-i))/Math.PI;return n<0?0:n>1?1:n}function p(t){const i=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(i))/Math.PI-90}},53714:(t,i,n)=>{n.d(i,{A:()=>e});const e="#version 300 es\n#define SHADER_NAME scatterplot-layer-vertex-shader\nin vec3 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin float instanceRadius;\nin float instanceLineWidths;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\nout vec4 vFillColor;\nout vec4 vLineColor;\nout vec2 unitPosition;\nout float innerUnitRadius;\nout float outerRadiusPixels;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\nouterRadiusPixels = clamp(\nproject_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),\nscatterplot.radiusMinPixels, scatterplot.radiusMaxPixels\n);\nfloat lineWidthPixels = clamp(\nproject_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),\nscatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels\n);\nouterRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;\nfloat edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\nunitPosition = edgePadding * positions.xy;\ngeometry.uv = unitPosition;\ngeometry.pickingColor = instancePickingColors;\ninnerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;\nif (scatterplot.billboard) {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = edgePadding * positions * outerRadiusPixels;\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vFillColor, geometry);\nvLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n"},64409:(t,i,n)=>{n.d(i,{F:()=>s});const e="uniform scatterplotUniforms {\n  float radiusScale;\n  float radiusMinPixels;\n  float radiusMaxPixels;\n  float lineWidthScale;\n  float lineWidthMinPixels;\n  float lineWidthMaxPixels;\n  float stroked;\n  float filled;\n  bool antialiasing;\n  bool billboard;\n  highp int radiusUnits;\n  highp int lineWidthUnits;\n} scatterplot;\n",s={name:"scatterplot",vs:e,fs:e,source:"",uniformTypes:{radiusScale:"f32",radiusMinPixels:"f32",radiusMaxPixels:"f32",lineWidthScale:"f32",lineWidthMinPixels:"f32",lineWidthMaxPixels:"f32",stroked:"f32",filled:"f32",antialiasing:"f32",billboard:"f32",radiusUnits:"i32",lineWidthUnits:"i32"}}},98543:(t,i,n)=>{n.d(i,{A:()=>v});var e=n(9350),s=n(46487),o=n(84175),r=n(83895),a=n(67118),l=n(33027),c=n(25337),d=n(64409),u=n(53714),p=n(42124),h=n(12228);const f=[0,0,0,255],g={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:t=>t.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:f},getLineColor:{type:"accessor",value:f},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class y extends a.A{getShaders(){return super.getShaders({vs:u.A,fs:p.A,source:h.A,modules:[o.A,s.A,r.A,d.F]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(t){super.updateState(t),t.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:t}){const{radiusUnits:i,radiusScale:n,radiusMinPixels:s,radiusMaxPixels:o,stroked:r,filled:a,billboard:l,antialiasing:c,lineWidthUnits:d,lineWidthScale:u,lineWidthMinPixels:p,lineWidthMaxPixels:h}=this.props,f={stroked:r,filled:a,billboard:l,antialiasing:c,radiusUnits:e.p5[i],radiusScale:n,radiusMinPixels:s,radiusMaxPixels:o,lineWidthUnits:e.p5[d],lineWidthScale:u,lineWidthMinPixels:p,lineWidthMaxPixels:h},g=this.state.model;g.shaderInputs.setProps({scatterplot:f}),"webgpu"===this.context.device.type&&(g.instanceCount=this.props.data.length),g.draw(this.context.renderPass)}_getModel(){const t="webgpu"===this.context.device.type?{depthWriteEnabled:!0,depthCompare:"less-equal"}:void 0;return new l.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new c.V({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,-1,1,0,1,1,0])}}}),isInstanced:!0,parameters:t})}}y.defaultProps=g,y.layerName="ScatterplotLayer";const v=y}}]);