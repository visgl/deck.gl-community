"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[6389],{6423:(t,i,n)=>{n.d(i,{E:()=>s,I:()=>l});var e=n(64960),o=n(76520);const r=85.051129;function l(t,i){const{size:n=2,startIndex:o=0,endIndex:r=t.length,normalize:l=!0}=i||{},s=t.slice(o,r);h(s,n,0,r-o);const a=(0,e.M)(s,{size:n,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(l)for(const e of a)c(e,n);return a}function s(t,i=null,n){const{size:o=2,normalize:r=!0,edgeTypes:l=!1}=n||{};i=i||[];const s=[],f=[];let u=0,d=0;for(let e=0;e<=i.length;e++){const r=i[e]||t.length,l=d,c=a(t,o,u,r);for(let i=c;i<r;i++)s[d++]=t[i];for(let i=u;i<c;i++)s[d++]=t[i];h(s,o,l,d),g(s,o,l,d,n?.maxLatitude),u=r,f[e]=d}f.pop();const p=(0,e.w)(s,f,{size:o,gridResolution:360,gridOffset:[-180,-180],edgeTypes:l});if(r)for(const e of p)c(e.positions,o);return p}function a(t,i,n,e){let o=-1,r=-1;for(let l=n+1;l<e;l+=i){const i=Math.abs(t[l]);i>o&&(o=i,r=l-1)}return r}function g(t,i,n,e,l=r){const s=t[n],a=t[e-i];if(Math.abs(s-a)>180){const e=(0,o.ah)(t,0,i,n);e[0]+=360*Math.round((a-s)/360),(0,o.VC)(t,e),e[1]=Math.sign(e[1])*l,(0,o.VC)(t,e),e[0]=s,(0,o.VC)(t,e)}}function h(t,i,n,e){let o,r=t[0];for(let l=n;l<e;l+=i){o=t[l];const i=o-r;(i>180||i<-180)&&(o-=360*Math.round(i/360)),t[l]=r=o}}function c(t,i){let n;const e=t.length/i;for(let r=0;r<e&&(n=t[r*i],(n+180)%360==0);r++);const o=360*-Math.round(n/360);if(0!==o)for(let r=0;r<e;r++)t[r*i]+=o}},18135:(t,i,n)=>{n.d(i,{UD:()=>o,rJ:()=>e});const e={CLOCKWISE:1,COUNTER_CLOCKWISE:-1};function o(t,i,n={}){const e=function(t,i={}){return Math.sign(function(t,i={}){const{start:n=0,end:e=t.length,plane:o="xy"}=i,l=i.size||2;let s=0;const a=r[o[0]],g=r[o[1]];for(let r=n,h=e-l;r<e;r+=l)s+=(t[r+a]-t[h+a])*(t[r+g]+t[h+g]),h=r;return s/2}(t,i))}(t,n);return e!==i&&(function(t,i){const{start:n=0,end:e=t.length,size:o=2}=i,r=(e-n)/o,l=Math.floor(r/2);for(let s=0;s<l;++s){const i=n+s*o,e=n+(r-1-s)*o;for(let n=0;n<o;++n){const o=t[i+n];t[i+n]=t[e+n],t[e+n]=o}}}(t,n),!0)}const r={x:0,y:1,z:2}},29479:(t,i,n)=>{n(18135)},38846:(t,i,n)=>{n.d(i,{X:()=>e,l:()=>o});const e="uniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n",o="#define MAX_LIGHTS 3\n\nuniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n  vec3 halfway_direction = normalize(light_direction + view_direction);\n  float lambertian = dot(light_direction, normal_worldspace);\n  float specular = 0.0;\n  if (lambertian > 0.0) {\n    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  vec3 view_direction = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  for (int i = 0; i < lighting.pointLightCount; i++) {\n    PointLight pointLight = lighting_getPointLight(i);\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);\n  }\n\n  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);\n  for (int i = lighting.pointLightCount; i < totalLights; i++) {\n    DirectionalLight directionalLight = lighting_getDirectionalLight(i);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n}\n"},44941:(t,i,n)=>{n.d(i,{A:()=>s});var e=n(53439),o=n(23459),r=n(24067),l=n(26839);class s{constructor(t){this.indexStarts=[0],this.vertexStarts=[0],this.vertexCount=0,this.instanceCount=0;const{attributes:i={}}=t;this.typedArrayManager=o.A,this.attributes={},this._attributeDefs=i,this.opts=t,this.updateGeometry(t)}updateGeometry(t){Object.assign(this.opts,t);const{data:i,buffers:n={},getGeometry:e,geometryBuffer:o,positionFormat:l,dataChanged:s,normalize:a=!0}=this.opts;if(this.data=i,this.getGeometry=e,this.positionSize=o&&o.size||("XY"===l?2:3),this.buffers=n,this.normalize=a,o&&((0,r.A)(i.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),a||(n.vertexPositions=o)),this.geometryBuffer=n.vertexPositions,Array.isArray(s))for(const r of s)this._rebuildGeometry(r);else this._rebuildGeometry()}updatePartialGeometry({startRow:t,endRow:i}){this._rebuildGeometry({startRow:t,endRow:i})}getGeometryFromBuffer(t){const i=t.value||t;return ArrayBuffer.isView(i)?(0,e.I)(i,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices}):null}_allocate(t,i){const{attributes:n,buffers:e,_attributeDefs:o,typedArrayManager:r}=this;for(const l in o)if(l in e)r.release(n[l]),n[l]=null;else{const e=o[l];e.copy=i,n[l]=r.allocate(n[l],t,e)}}_forEachGeometry(t,i,n){const{data:o,getGeometry:r}=this,{iterable:l,objectInfo:s}=(0,e.X)(o,i,n);for(const e of l){s.index++;t(r?r(e,s):null,s.index)}}_rebuildGeometry(t){if(!this.data)return;let{indexStarts:i,vertexStarts:n,instanceCount:e}=this;const{data:o,geometryBuffer:r}=this,{startRow:s=0,endRow:a=1/0}=t||{},g={};if(t||(i=[0],n=[0]),this.normalize||!r)this._forEachGeometry((t,i)=>{const e=t&&this.normalizeGeometry(t);g[i]=e,n[i+1]=n[i]+(e?this.getGeometrySize(e):0)},s,a),e=n[n.length-1];else if(n=o.startIndices,e=n[o.length]||0,ArrayBuffer.isView(r))e=e||r.length/this.positionSize;else if(r instanceof l.h){const t=4*this.positionSize;e=e||r.byteLength/t}else if(r.buffer){const t=r.stride||4*this.positionSize;e=e||r.buffer.byteLength/t}else if(r.value){const t=r.value,i=r.stride/t.BYTES_PER_ELEMENT||this.positionSize;e=e||t.length/i}this._allocate(e,Boolean(t)),this.indexStarts=i,this.vertexStarts=n,this.instanceCount=e;const h={};this._forEachGeometry((t,o)=>{const r=g[o]||t;h.vertexStart=n[o],h.indexStart=i[o];const l=o<n.length-1?n[o+1]:e;h.geometrySize=l-n[o],h.geometryIndex=o,this.updateGeometryAttributes(r,h)},s,a),this.vertexCount=i[i.length-1]}}},46409:(t,i,n)=>{n.d(i,{x:()=>s});var e=n(29651),o=n(78998),r=n(78135);var l;!function(t){t[t.POINT=0]="POINT",t[t.DIRECTIONAL=1]="DIRECTIONAL"}(l||(l={}));const s={props:{},uniforms:{},name:"lighting",defines:{},uniformTypes:{enabled:"i32",lightType:"i32",directionalLightCount:"i32",pointLightCount:"i32",ambientColor:"vec3<f32>",lightColor0:"vec3<f32>",lightPosition0:"vec3<f32>",lightDirection0:"vec3<f32>",lightAttenuation0:"vec3<f32>",lightColor1:"vec3<f32>",lightPosition1:"vec3<f32>",lightDirection1:"vec3<f32>",lightAttenuation1:"vec3<f32>",lightColor2:"vec3<f32>",lightPosition2:"vec3<f32>",lightDirection2:"vec3<f32>",lightAttenuation2:"vec3<f32>"},defaultUniforms:{enabled:1,lightType:l.POINT,directionalLightCount:0,pointLightCount:0,ambientColor:[.1,.1,.1],lightColor0:[1,1,1],lightPosition0:[1,1,2],lightDirection0:[1,1,1],lightAttenuation0:[1,0,0],lightColor1:[1,1,1],lightPosition1:[1,1,2],lightDirection1:[1,1,1],lightAttenuation1:[1,0,0],lightColor2:[1,1,1],lightPosition2:[1,1,2],lightDirection2:[1,1,1],lightAttenuation2:[1,0,0]},source:r.h,vs:o.c,fs:o.c,getUniforms:function(t,i={}){if(!(t=t?{...t}:t))return{...s.defaultUniforms};t.lights&&(t={...t,...g(t.lights),lights:void 0});const{ambientLight:n,pointLights:e,directionalLights:o}=t||{};if(!(n||e&&e.length>0||o&&o.length>0))return{...s.defaultUniforms,enabled:0};const r={...s.defaultUniforms,...i,...a({ambientLight:n,pointLights:e,directionalLights:o})};void 0!==t.enabled&&(r.enabled=t.enabled?1:0);return r}};function a({ambientLight:t,pointLights:i=[],directionalLights:n=[]}){const o={};o.ambientColor=h(t);let r=0;for(const e of i){o.lightType=l.POINT;const t=r;o[`lightColor${t}`]=h(e),o[`lightPosition${t}`]=e.position,o[`lightAttenuation${t}`]=e.attenuation||[1,0,0],r++}for(const e of n){o.lightType=l.DIRECTIONAL;const t=r;o[`lightColor${t}`]=h(e),o[`lightDirection${t}`]=e.direction,r++}return r>5&&e.R.warn("MAX_LIGHTS exceeded")(),o.directionalLightCount=n.length,o.pointLightCount=i.length,o}function g(t){const i={pointLights:[],directionalLights:[]};for(const n of t||[])switch(n.type){case"ambient":i.ambientLight=n;break;case"directional":i.directionalLights?.push(n);break;case"point":i.pointLights?.push(n)}return i}function h(t={}){const{color:i=[0,0,0],intensity:n=1}=t;return i.map(t=>t*n/255)}},59452:(t,i,n)=>{n.d(i,{A:()=>a});var e=n(67118),o=n(43411),r=n(38055),l=n(12897);class s extends e.A{get isComposite(){return!0}get isDrawable(){return!1}get isLoaded(){return super.isLoaded&&this.getSubLayers().every(t=>t.isLoaded)}getSubLayers(){return this.internalState&&this.internalState.subLayers||[]}initializeState(t){}setState(t){super.setState(t),this.setNeedsUpdate()}getPickingInfo({info:t}){const{object:i}=t;return i&&i.__source&&i.__source.parent&&i.__source.parent.id===this.id?(t.object=i.__source.object,t.index=i.__source.index,t):t}filterSubLayer(t){return!0}shouldRenderSubLayer(t,i){return i&&i.length}getSubLayerClass(t,i){const{_subLayerProps:n}=this.props;return n&&n[t]&&n[t].type||i}getSubLayerRow(t,i,n){return t.__source={parent:this,object:i,index:n},t}getSubLayerAccessor(t){if("function"==typeof t){const i={index:-1,data:this.props.data,target:[]};return(n,e)=>n&&n.__source?(i.index=n.__source.index,t(n.__source.object,i)):t(n,e)}return t}getSubLayerProps(t={}){const{opacity:i,pickable:n,visible:e,parameters:o,getPolygonOffset:r,highlightedObjectIndex:s,autoHighlight:a,highlightColor:g,coordinateSystem:h,coordinateOrigin:c,wrapLongitude:f,positionFormat:u,modelMatrix:d,extensions:p,fetch:L,operation:_,_subLayerProps:m}=this.props,C={id:"",updateTriggers:{},opacity:i,pickable:n,visible:e,parameters:o,getPolygonOffset:r,highlightedObjectIndex:s,autoHighlight:a,highlightColor:g,coordinateSystem:h,coordinateOrigin:c,wrapLongitude:f,positionFormat:u,modelMatrix:d,extensions:p,fetch:L,operation:_},v=m&&t.id&&m[t.id],y=v&&v.updateTriggers,b=t.id||"sublayer";if(v){const i=this.props[l.fW],n=t.type?t.type._propTypes:{};for(const t in v){const e=n[t]||i[t];e&&"accessor"===e.type&&(v[t]=this.getSubLayerAccessor(v[t]))}}Object.assign(C,t,v),C.id=`${this.props.id}-${b}`,C.updateTriggers={all:this.props.updateTriggers?.all,...t.updateTriggers,...y};for(const l of p){const t=l.getSubLayerProps.call(this,l);t&&Object.assign(C,t,{updateTriggers:Object.assign(C.updateTriggers,t.updateTriggers)})}return C}_updateAutoHighlight(t){for(const i of this.getSubLayers())i.updateAutoHighlight(t)}_getAttributeManager(){return null}_postUpdate(t,i){let n=this.internalState.subLayers;const e=!n||this.needsUpdate();if(e){const t=this.renderLayers();n=(0,r.B)(t,Boolean),this.internalState.subLayers=n}(0,o.A)("compositeLayer.renderLayers",this,e,n);for(const o of n)o.parent=this}}s.layerName="CompositeLayer";const a=s},64960:(t,i,n)=>{n.d(i,{M:()=>r,w:()=>a});var e=n(87901),o=n(76520);function r(t,i){const{size:n=2,broken:r=!1,gridResolution:l=10,gridOffset:s=[0,0],startIndex:a=0,endIndex:g=t.length}=i||{},f=(g-a)/n;let u=[];const d=[u],p=(0,o.ah)(t,0,n,a);let L,_;const m=h(p,l,s,[]),C=[];(0,o.VC)(u,p);for(let h=1;h<f;h++){for(L=(0,o.ah)(t,h,n,a,L),_=(0,e.BU)(L,m);_;){(0,e.y$)(p,L,_,m,C);const t=(0,e.BU)(C,m);t&&((0,e.y$)(p,C,t,m,C),_=t),(0,o.VC)(u,C),(0,o.C)(p,C),c(m,l,_),r&&u.length>n&&(u=[],d.push(u),(0,o.VC)(u,p)),_=(0,e.BU)(L,m)}(0,o.VC)(u,L),(0,o.C)(p,L)}return r?d:d[0]}const l=0,s=1;function a(t,i=null,n){if(!t.length)return[];const{size:o=2,gridResolution:r=10,gridOffset:l=[0,0],edgeTypes:a=!1}=n||{},c=[],d=[{pos:t,types:a?new Array(t.length/o).fill(s):null,holes:i||[]}],p=[[],[]];let L=[];for(;d.length;){const{pos:t,types:i,holes:n}=d.shift();f(t,o,n[0]||t.length,p),L=h(p[0],r,l,L);const s=(0,e.BU)(p[1],L);if(s){let e=g(t,i,o,0,n[0]||t.length,L,s);const r={pos:e[0].pos,types:e[0].types,holes:[]},l={pos:e[1].pos,types:e[1].types,holes:[]};d.push(r,l);for(let h=0;h<n.length;h++)e=g(t,i,o,n[h],n[h+1]||t.length,L,s),e[0]&&(r.holes.push(r.pos.length),r.pos=u(r.pos,e[0].pos),a&&(r.types=u(r.types,e[0].types))),e[1]&&(l.holes.push(l.pos.length),l.pos=u(l.pos,e[1].pos),a&&(l.types=u(l.types,e[1].types)))}else{const e={positions:t};a&&(e.edgeTypes=i),n.length&&(e.holeIndices=n),c.push(e)}}return c}function g(t,i,n,r,s,a,g){const h=(s-r)/n,c=[],f=[],u=[],d=[],p=[];let L,_,m;const C=(0,o.ah)(t,h-1,n,r);let v=Math.sign(8&g?C[1]-a[3]:C[0]-a[2]),y=i&&i[h-1],b=0,w=0;for(let P=0;P<h;P++)L=(0,o.ah)(t,P,n,r,L),_=Math.sign(8&g?L[1]-a[3]:L[0]-a[2]),m=i&&i[r/n+P],_&&v&&v!==_&&((0,e.y$)(C,L,g,a,p),(0,o.VC)(c,p)&&u.push(y),(0,o.VC)(f,p)&&d.push(y)),_<=0?((0,o.VC)(c,L)&&u.push(m),b-=_):u.length&&(u[u.length-1]=l),_>=0?((0,o.VC)(f,L)&&d.push(m),w+=_):d.length&&(d[d.length-1]=l),(0,o.C)(C,L),v=_,y=m;return[b?{pos:c,types:i&&u}:null,w?{pos:f,types:i&&d}:null]}function h(t,i,n,e){const o=Math.floor((t[0]-n[0])/i)*i+n[0],r=Math.floor((t[1]-n[1])/i)*i+n[1];return e[0]=o,e[1]=r,e[2]=o+i,e[3]=r+i,e}function c(t,i,n){8&n?(t[1]+=i,t[3]+=i):4&n?(t[1]-=i,t[3]-=i):2&n?(t[0]+=i,t[2]+=i):1&n&&(t[0]-=i,t[2]-=i)}function f(t,i,n,e){let o=1/0,r=-1/0,l=1/0,s=-1/0;for(let a=0;a<n;a+=i){const i=t[a],n=t[a+1];o=i<o?i:o,r=i>r?i:r,l=n<l?n:l,s=n>s?n:s}return e[0][0]=o,e[0][1]=l,e[1][0]=r,e[1][1]=s,e}function u(t,i){for(let n=0;n<i.length;n++)t.push(i[n]);return t}},68285:(t,i,n)=>{n.d(i,{Eg:()=>r.E,Iy:()=>r.I,Mk:()=>o.M,UD:()=>e.UD,rJ:()=>e.rJ,wk:()=>o.w});n(29479);var e=n(18135),o=(n(76953),n(64960)),r=n(6423)},76520:(t,i,n)=>{function e(t,i){const n=i.length,e=t.length;if(e>0){let o=!0;for(let r=0;r<n;r++)if(t[e-n+r]!==i[r]){o=!1;break}if(o)return!1}for(let o=0;o<n;o++)t[e+o]=i[o];return!0}function o(t,i){const n=i.length;for(let e=0;e<n;e++)t[e]=i[e]}function r(t,i,n,e,o=[]){const r=e+i*n;for(let l=0;l<n;l++)o[l]=t[r+l];return o}n.d(i,{C:()=>o,VC:()=>e,ah:()=>r})},76953:(t,i,n)=>{n(18135)},78135:(t,i,n)=>{n.d(i,{h:()=>e});const e="// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  color: vec3<f32>,\n};\n\nstruct PointLight {\n  color: vec3<f32>,\n  position: vec3<f32>,\n  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  color: vec3<f32>,\n  direction: vec3<f32>,\n};\n\nstruct lightingUniforms {\n  enabled: i32,\n  pointLightCount: i32,\n  directionalLightCount: i32,\n\n  ambientColor: vec3<f32>,\n\n  // TODO - support multiple lights by uncommenting arrays below\n  lightType: i32,\n  lightColor: vec3<f32>,\n  lightDirection: vec3<f32>,\n  lightPosition: vec3<f32>,\n  lightAttenuation: vec3<f32>,\n\n  // AmbientLight ambientLight;\n  // PointLight pointLight[MAX_LIGHTS];\n  // DirectionalLight directionalLight[MAX_LIGHTS];\n};\n\n// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)\n@binding(1) @group(0) var<uniform> lighting : lightingUniforms;\n\nfn lighting_getPointLight(index: i32) -> PointLight {\n  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);\n}\n\nfn lighting_getDirectionalLight(index: i32) -> DirectionalLight {\n  return DirectionalLight(lighting.lightColor, lighting.lightDirection);\n} \n\nfn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n"},78998:(t,i,n)=>{n.d(i,{c:()=>e});const e="precision highp int;\n\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  vec3 color;\n};\n\nstruct PointLight {\n  vec3 color;\n  vec3 position;\n  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform lightingUniforms {\n  int enabled;\n  int lightType;\n\n  int directionalLightCount;\n  int pointLightCount;\n\n  vec3 ambientColor;\n\n  vec3 lightColor0;\n  vec3 lightPosition0;\n  vec3 lightDirection0;\n  vec3 lightAttenuation0;\n\n  vec3 lightColor1;\n  vec3 lightPosition1;\n  vec3 lightDirection1;\n  vec3 lightAttenuation1;\n\n  vec3 lightColor2;\n  vec3 lightPosition2;\n  vec3 lightDirection2;\n  vec3 lightAttenuation2;\n} lighting;\n\nPointLight lighting_getPointLight(int index) {\n  switch (index) {\n    case 0:\n      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);\n    case 1:\n      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);\n    case 2:\n    default:  \n      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);\n  }\n}\n\nDirectionalLight lighting_getDirectionalLight(int index) {\n  switch (index) {\n    case 0:\n      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);\n    case 1:\n      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);\n    case 2:\n    default:   \n      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);\n  }\n} \n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n// #endif\n"},79439:(t,i,n)=>{n.d(i,{X:()=>e});const e="struct phongMaterialUniforms {\n  ambient: f32,\n  diffuse: f32,\n  shininess: f32,\n  specularColor: vec3<f32>,\n};\n\n@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;\n\nfn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {\n  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);\n  var lambertian: f32 = dot(light_direction, normal_worldspace);\n  var specular: f32 = 0.0;\n  if (lambertian > 0.0) {\n    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, phongMaterial.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;\n}\n\nfn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {\n  var lightColor: vec3<f32> = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);\n  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;\n\n  if (lighting.lightType == 0) {\n    let pointLight: PointLight  = lighting_getPointLight(0);\n    let light_position_worldspace: vec3<f32> = pointLight.position;\n    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  } else if (lighting.lightType == 1) {\n    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n  /*\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.pointLightCount) {\n      break;\n    }\n    PointLight pointLight = lighting.pointLight[i];\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  }\n\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.directionalLightCount) {\n      break;\n    }\n    DirectionalLight directionalLight = lighting.directionalLight[i];\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  */\n}\n\nfn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{\n  var lightColor = vec3<f32>(0, 0, 0);\n  let surfaceColor = vec3<f32>(0, 0, 0);\n\n  if (lighting.enabled == 0) {\n    let view_direction = normalize(cameraPosition - position_worldspace);\n\n    switch (lighting.lightType) {\n      case 0, default: {\n        let pointLight: PointLight = lighting_getPointLight(0);\n        let light_position_worldspace: vec3<f32> = pointLight.position;\n        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n      }\n      case 1: {\n        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n      }\n    }\n  }\n  return lightColor;\n}\n"},87901:(t,i,n)=>{function e(t,i,n,e,o=[]){let r,l;if(8&n)r=(e[3]-t[1])/(i[1]-t[1]),l=3;else if(4&n)r=(e[1]-t[1])/(i[1]-t[1]),l=1;else if(2&n)r=(e[2]-t[0])/(i[0]-t[0]),l=2;else{if(!(1&n))return null;r=(e[0]-t[0])/(i[0]-t[0]),l=0}for(let s=0;s<t.length;s++)o[s]=(1&l)===s?e[l]:r*(i[s]-t[s])+t[s];return o}function o(t,i){let n=0;return t[0]<i[0]?n|=1:t[0]>i[2]&&(n|=2),t[1]<i[1]?n|=4:t[1]>i[3]&&(n|=8),n}n.d(i,{BU:()=>o,y$:()=>e})}}]);