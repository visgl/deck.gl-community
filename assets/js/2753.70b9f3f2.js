"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[2753],{454:(e,t,n)=>{function o(e){if(null==e)throw new TypeError("Cannot destructure "+e)}n.d(t,{A:()=>o})},840:(e,t,n)=>{n.d(t,{A:()=>w});var o=n(6540),i=n(8003);const r="undefined"!=typeof window?o.useLayoutEffect:o.useEffect;function s(e,t){for(;e;){if(e===t)return!0;e=Object.getPrototypeOf(e)}return!1}var c=n(1152),a=n(2146);const l={position:"absolute",zIndex:-1};function d(e,t){if("function"==typeof e)return e(t);if(Array.isArray(e))return e.map(e=>d(e,t));if(u(e)){if(n=e,n.props?.mapStyle)return t.style=l,(0,o.cloneElement)(e,t);if(function(e){const t=e.type;return t&&t.deckGLViewProps}(e))return(0,o.cloneElement)(e,t)}var n;return e}function u(e){return e&&"object"==typeof e&&"type"in e||!1}function f(e){if("function"==typeof e)return(0,o.createElement)(c.A,{},e);if(Array.isArray(e))return e.map(f);if(u(e)){if(e.type===o.Fragment)return f(e.props.children);if(s(e.type,c.A))return e}return e}const p=(0,o.createContext)();const v={mixBlendMode:null};function g(e){e.redrawReason&&(e.deck._drawLayers(e.redrawReason),e.redrawReason=null)}const h=o.forwardRef(function(e,t){const[n,l]=(0,o.useState)(0),h=(0,o.useRef)({control:null,version:n,forceUpdate:()=>l(e=>e+1)}).current,w=(0,o.useRef)(null),_=(0,o.useRef)(null),m=(0,o.useMemo)(()=>function({children:e,layers:t=[],views:n=null}){const i=[],r=[],l={};return o.Children.forEach(f(e),e=>{if(u(e)){const t=e.type;if(s(t,a.A)){const n=function(e,t){const n={},o=e.defaultProps||{};for(const i in t)o[i]!==t[i]&&(n[i]=t[i]);return new e(n)}(t,e.props);r.push(n)}else i.push(e);if(s(t,c.A)&&t!==c.A&&e.props.id){const n=new t(e.props);l[n.id]=n}}else e&&i.push(e)}),Object.keys(l).length>0&&(Array.isArray(n)?n.forEach(e=>{l[e.id]=e}):n&&(l[n.id]=n),n=Object.values(l)),{layers:t=r.length>0?[...r,...t]:t,children:i,views:n}}(e),[e.layers,e.views,e.children]);let y=!0;const P=t=>y&&e.viewState?(h.viewStateUpdateRequested=t,null):(h.viewStateUpdateRequested=null,e.onViewStateChange?.(t)),x=t=>{y?h.interactionStateUpdateRequested=t:(h.interactionStateUpdateRequested=null,e.onInteractionStateChange?.(t))},S=(0,o.useMemo)(()=>{const t={widgets:[],...e,style:null,width:"100%",height:"100%",parent:w.current,canvas:_.current,layers:m.layers,views:m.views,onViewStateChange:P,onInteractionStateChange:x};return delete t._customRender,h.deck&&h.deck.setProps(t),t},[e]);(0,o.useEffect)(()=>{const t=e.Deck||i.A;return h.deck=function(e,t,n){const o=new t({...n,_customRender:"webgpu"===n.deviceProps?.adapters?.[0]?.type?void 0:t=>{e.redrawReason=t;const n=o.getViewports();e.lastRenderedViewports!==n?e.forceUpdate():g(e)}});return o}(h,t,{...S,parent:w.current,canvas:_.current}),()=>h.deck?.finalize()},[]),r(()=>{g(h);const{viewStateUpdateRequested:e,interactionStateUpdateRequested:t}=h;e&&P(e),t&&x(t),h.deck?.isInitialized&&h.deck.redraw("Initial render")}),(0,o.useImperativeHandle)(t,()=>function(e){return{get deck(){return e.deck},pickObject:t=>e.deck.pickObject(t),pickMultipleObjects:t=>e.deck.pickMultipleObjects(t),pickObjects:t=>e.deck.pickObjects(t)}}(h),[]);const C=h.deck&&h.deck.isInitialized?h.deck.getViewports():void 0,{ContextProvider:b,width:k="100%",height:L="100%",id:A,style:M}=e,{containerStyle:R,canvasStyle:E}=(0,o.useMemo)(()=>function({width:e,height:t,style:n}){const o={position:"absolute",zIndex:0,left:0,top:0,width:e,height:t},i={left:0,top:0};if(n)for(const r in n)r in v?i[r]=n[r]:o[r]=n[r];return{containerStyle:o,canvasStyle:i}}({width:k,height:L,style:M}),[k,L,M]);if(!h.viewStateUpdateRequested&&h.lastRenderedViewports===C||h.version!==n){h.lastRenderedViewports=C,h.version=n;const e=function({children:e,deck:t,ContextProvider:n=p.Provider}){const{viewManager:i}=t||{};if(!i||!i.views.length)return[];const r={},a=i.views[0].id;for(const o of e){let e=a,t=o;u(o)&&s(o.type,c.A)&&(e=o.props.id||a,t=o.props.children);const n=i.getViewport(e),l=i.getViewState(e);if(n){l.padding=n.padding;const{x:o,y:i,width:s,height:c}=n;t=d(t,{x:o,y:i,width:s,height:c,viewport:n,viewState:l}),r[e]||(r[e]={viewport:n,children:[]}),r[e].children.push(t)}}return Object.keys(r).map(e=>{const{viewport:i,children:s}=r[e],{x:c,y:a,width:l,height:d}=i,u={position:"absolute",left:c,top:a,width:l,height:d},f=`view-${e}`,p=(0,o.createElement)("div",{key:f,id:f,style:u},...s),v={deck:t,viewport:i,container:t.canvas.offsetParent,eventManager:t.eventManager,onViewStateChange:n=>{n.viewId=e,t._onViewStateChange(n)},widgets:[]},g=`view-${e}-context`;return(0,o.createElement)(n,{key:g,value:v},p)})}({children:m.children,deck:h.deck,ContextProvider:b}),t=(0,o.createElement)("canvas",{key:"canvas",id:A||"deckgl-overlay",ref:_,style:E});h.control=(0,o.createElement)("div",{id:`${A||"deckgl"}-wrapper`,ref:w,style:R},[t,e])}return y=!1,h.control}),w=h},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var o=n(6540);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}},9105:(e,t,n)=>{n.d(t,{A:()=>v});var o=n(2146),i=n(4175),r=n(6487),s=n(3349),c=n(9350),a=n(4947),l=n(5337);const d="uniform lineUniforms {\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  float useShortestPath;\n  highp int widthUnits;\n} line;\n",u={name:"line",source:"struct LineUniforms {\n  widthScale: f32,\n  widthMinPixels: f32,\n  widthMaxPixels: f32,\n  useShortestPath: f32,\n  widthUnits: i32,\n};\n\n@group(0) @binding(1)\nvar<uniform> line: LineUniforms;\n",vs:d,fs:d,uniformTypes:{widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",useShortestPath:"f32",widthUnits:"i32"}},f={getSourcePosition:{type:"accessor",value:e=>e.sourcePosition},getTargetPosition:{type:"accessor",value:e=>e.targetPosition},getColor:{type:"accessor",value:[0,0,0,255]},getWidth:{type:"accessor",value:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class p extends o.A{getBounds(){return this.getAttributeManager()?.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME line-layer-vertex-shader\nin vec3 positions;\nin vec3 instanceSourcePositions;\nin vec3 instanceTargetPositions;\nin vec3 instanceSourcePositions64Low;\nin vec3 instanceTargetPositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin float instanceWidths;\nout vec4 vColor;\nout vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\nvec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);\ndir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\nreturn dir_screenspace * offset_direction * width / 2.0;\n}\nvec3 splitLine(vec3 a, vec3 b, float x) {\nfloat t = (x - a.x) / (b.x - a.x);\nreturn vec3(x, mix(a.yz, b.yz, t));\n}\nvoid main(void) {\ngeometry.worldPosition = instanceSourcePositions;\ngeometry.worldPositionAlt = instanceTargetPositions;\nvec3 source_world = instanceSourcePositions;\nvec3 target_world = instanceTargetPositions;\nvec3 source_world_64low = instanceSourcePositions64Low;\nvec3 target_world_64low = instanceTargetPositions64Low;\nif (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {\nsource_world.x = mod(source_world.x + 180., 360.0) - 180.;\ntarget_world.x = mod(target_world.x + 180., 360.0) - 180.;\nfloat deltaLng = target_world.x - source_world.x;\nif (deltaLng * line.useShortestPath > 180.) {\nsource_world.x += 360. * line.useShortestPath;\nsource_world = splitLine(source_world, target_world, 180. * line.useShortestPath);\nsource_world_64low = vec3(0.0);\n} else if (deltaLng * line.useShortestPath < -180.) {\ntarget_world.x += 360. * line.useShortestPath;\ntarget_world = splitLine(source_world, target_world, 180. * line.useShortestPath);\ntarget_world_64low = vec3(0.0);\n} else if (line.useShortestPath < 0.) {\ngl_Position = vec4(0.);\nreturn;\n}\n}\nvec4 source_commonspace;\nvec4 target_commonspace;\nvec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\nvec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\nfloat segmentIndex = positions.x;\nvec4 p = mix(source, target, segmentIndex);\ngeometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\nuv = positions.xy;\ngeometry.uv = uv;\ngeometry.pickingColor = instancePickingColors;\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),\nline.widthMinPixels, line.widthMaxPixels\n);\nvec3 offset = vec3(\ngetExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\nDECKGL_FILTER_GL_POSITION(p, geometry);\ngl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\nvColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME line-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 uv;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = uv;\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",source:'// ---------- Helper Structures & Functions ----------\n\n// Placeholder filter functions.\nfn deckgl_filter_size(offset: vec3<f32>, geometry: Geometry) -> vec3<f32> {\n  return offset;\n}\nfn deckgl_filter_gl_position(p: vec4<f32>, geometry: Geometry) -> vec4<f32> {\n  return p;\n}\nfn deckgl_filter_color(color: vec4<f32>, geometry: Geometry) -> vec4<f32> {\n  return color;\n}\n\n// Compute an extrusion offset given a line direction (in clipspace),\n// an offset direction (-1 or 1), and a width in pixels.\n// Assumes a uniform "project" with a viewportSize field is available.\nfn getExtrusionOffset(line_clipspace: vec2<f32>, offset_direction: f32, width: f32) -> vec2<f32> {\n  // project.viewportSize should be provided as a uniform (not shown here)\n  let dir_screenspace = normalize(line_clipspace * project.viewportSize);\n  // Rotate by 90\xb0: (x,y) becomes (-y,x)\n  let rotated = vec2<f32>(-dir_screenspace.y, dir_screenspace.x);\n  return rotated * offset_direction * width / 2.0;\n}\n\n// Splits the line between two points at a given x coordinate.\n// Interpolates the y and z components.\nfn splitLine(a: vec3<f32>, b: vec3<f32>, x: f32) -> vec3<f32> {\n  let t: f32 = (x - a.x) / (b.x - a.x);\n  return vec3<f32>(x, a.yz + t * (b.yz - a.yz));\n}\n\n// ---------- Uniforms & Global Structures ----------\n\n// Uniforms for line, color, and project are assumed to be defined elsewhere.\n// For example:\n//\n// @group(0) @binding(0)\n// var<uniform> line: LineUniform;\n//\n// struct ColorUniform {\n//   opacity: f32,\n// };\n// @group(0) @binding(1)\n// var<uniform> color: ColorUniform;\n//\n// struct ProjectUniform {\n//   viewportSize: vec2<f32>,\n// };\n// @group(0) @binding(2)\n// var<uniform> project: ProjectUniform;\n\n\n\n// ---------- Vertex Output Structure ----------\n\nstruct Varyings {\n  @builtin(position) gl_Position: vec4<f32>,\n  @location(0) vColor: vec4<f32>,\n  @location(1) uv: vec2<f32>,\n};\n\n// ---------- Vertex Shader Entry Point ----------\n\n@vertex\nfn vertexMain(\n  @location(0) positions: vec3<f32>,\n  @location(1) instanceSourcePositions: vec3<f32>,\n  @location(2) instanceTargetPositions: vec3<f32>,\n  @location(3) instanceSourcePositions64Low: vec3<f32>,\n  @location(4) instanceTargetPositions64Low: vec3<f32>,\n  @location(5) instanceColors: vec4<f32>,\n  @location(6) instancePickingColors: vec3<f32>,\n  @location(7) instanceWidths: f32\n) -> Varyings {\n  var geometry: Geometry;\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  var source_world: vec3<f32> = instanceSourcePositions;\n  var target_world: vec3<f32> = instanceTargetPositions;\n  var source_world_64low: vec3<f32> = instanceSourcePositions64Low;\n  var target_world_64low: vec3<f32> = instanceTargetPositions64Low;\n\n  // Apply shortest-path adjustments if needed.\n  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {\n    source_world.x = (source_world.x + 180.0 % 360.0) - 180.0;\n    target_world.x = (target_world.x + 180.0 % 360.0) - 180.0;\n    let deltaLng: f32 = target_world.x - source_world.x;\n\n    if (deltaLng * line.useShortestPath > 180.0) {\n      source_world.x = source_world.x + 360.0 * line.useShortestPath;\n      source_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);\n      source_world_64low = vec3<f32>(0.0, 0.0, 0.0);\n    } else if (deltaLng * line.useShortestPath < -180.0) {\n      target_world.x = target_world.x + 360.0 * line.useShortestPath;\n      target_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);\n      target_world_64low = vec3<f32>(0.0, 0.0, 0.0);\n    } else if (line.useShortestPath < 0.0) {\n      var abortOut: Varyings;\n      abortOut.gl_Position = vec4<f32>(0.0);\n      abortOut.vColor = vec4<f32>(0.0);\n      abortOut.uv = vec2<f32>(0.0);\n      return abortOut;\n    }\n  }\n\n  // Project Pos and target positions to clip space.\n  let sourceResult = project_position_to_clipspace_and_commonspace(source_world, source_world_64low, vec3<f32>(0.0));\n  let targetResult = project_position_to_clipspace_and_commonspace(target_world, target_world_64low, vec3<f32>(0.0));\n  let sourcePos: vec4<f32> = sourceResult.clipPosition;\n  let targetPos: vec4<f32> = targetResult.clipPosition;\n  let source_commonspace: vec4<f32> = sourceResult.commonPosition;\n  let target_commonspace: vec4<f32> = targetResult.commonPosition;\n\n  // Interpolate along the line segment.\n  let segmentIndex: f32 = positions.x;\n  let p: vec4<f32> = sourcePos + segmentIndex * (targetPos - sourcePos);\n  geometry.position = source_commonspace + segmentIndex * (target_commonspace - source_commonspace);\n  let uv: vec2<f32> = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  // Determine width in pixels.\n  let widthPixels: f32 = clamp(\n    project_unit_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),\n    line.widthMinPixels, line.widthMaxPixels\n  );\n\n  // Compute extrusion offset.\n  let extrusion: vec2<f32> = getExtrusionOffset(targetPos.xy - sourcePos.xy, positions.y, widthPixels);\n  let offset: vec3<f32> = vec3<f32>(extrusion, 0.0);\n\n  // Apply deck.gl filter functions.\n  let filteredOffset = deckgl_filter_size(offset, geometry);\n  let filteredP = deckgl_filter_gl_position(p, geometry);\n\n  let clipOffset: vec2<f32> = project_pixel_size_to_clipspace(filteredOffset.xy);\n  let finalPosition: vec4<f32> = filteredP + vec4<f32>(clipOffset, 0.0, 0.0);\n\n  // Compute color.\n  var vColor: vec4<f32> = vec4<f32>(instanceColors.rgb, instanceColors.a * color.opacity);\n  // vColor = deckgl_filter_color(vColor, geometry);\n\n  var output: Varyings;\n  output.gl_Position = finalPosition;\n  output.vColor = vColor;\n  output.uv = uv;\n  return output;\n}\n\n@fragment\nfn fragmentMain(\n  @location(0) vColor: vec4<f32>,\n  @location(1) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n  // Create and initialize geometry with the provided uv.\n  var geometry: Geometry;\n  geometry.uv = uv;\n\n  // Start with the input color.\n  var fragColor: vec4<f32> = vColor;\n\n  // Apply the deck.gl filter to the color.\n  fragColor = deckgl_filter_color(fragColor, geometry);\n\n  // Apply premultiplied alpha as required by transparent canvas\n  fragColor = deckgl_premultiplied_alpha(fragColor);\n\n  return fragColor;\n}\n',modules:[i.A,r.A,s.A,u]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:[0,0,0,255]},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1}})}updateState(e){super.updateState(e),e.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:e}){const{widthUnits:t,widthScale:n,widthMinPixels:o,widthMaxPixels:i,wrapLongitude:r}=this.props,s=this.state.model,a={widthUnits:c.p5[t],widthScale:n,widthMinPixels:o,widthMaxPixels:i,useShortestPath:r?1:0};s.shaderInputs.setProps({line:a}),s.draw(this.context.renderPass),r&&(s.shaderInputs.setProps({line:{...a,useShortestPath:-1}}),s.draw(this.context.renderPass))}_getModel(){const e="webgpu"===this.context.device.type?{depthWriteEnabled:!0,depthCompare:"less-equal"}:void 0;return new a.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new l.V({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array([0,-1,0,0,1,0,1,-1,0,1,1,0])}}}),parameters:e,isInstanced:!0})}}p.layerName="LineLayer",p.defaultProps=f;const v=p},9813:(e,t,n)=>{n.d(t,{A:()=>r});n(6540);var o=n(1062),i=n(4848);function r(e){let{children:t,fallback:n}=e;return(0,o.A)()?(0,i.jsx)(i.Fragment,{children:null==t?void 0:t()}):null!=n?n:null}}}]);