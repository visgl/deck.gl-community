"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[9972],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(96540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}},34254:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var o=t(43456),s=t(74848),i=t(28453);const r={},a="GraphLayout",l={},d=[{value:"Usage",id:"usage",level:2},{value:"The layout lifecycle",id:"the-layout-lifecycle",level:2},{value:"Lifecycle phases",id:"lifecycle-phases",level:3},{value:"Emitting layout events",id:"emitting-layout-events",level:3},{value:"GraphLayoutEventDetail",id:"graphlayouteventdetail",level:3},{value:"Maintaining layout bounds",id:"maintaining-layout-bounds",level:3},{value:"Drag interactions",id:"drag-interactions",level:3},{value:"Accessors",id:"accessors",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"graphlayout",children:"GraphLayout"})}),"\n",(0,s.jsxs)(n.p,{children:["Create a subclass of the ",(0,s.jsx)(n.code,{children:"GraphLayout"})," class to implement a custom layout for the ",(0,s.jsx)(n.code,{children:"GraphLayer"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsxs)(n.p,{children:["The recommended pattern is to implement a strongly typed subclass that defines its own default props, forwards them to ",(0,s.jsx)(n.code,{children:"GraphLayout"}),", and emits layout lifecycle events when positions change."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import type {\n  ClassicGraph,\n  EdgeInterface,\n  GraphLayoutProps,\n  NodeInterface\n} from '@deck.gl-community/graph-layers';\nimport {GraphLayout} from '@deck.gl-community/graph-layers';\n\ntype RandomLayoutProps = GraphLayoutProps & {\n  viewportWidth: number;\n  viewportHeight: number;\n};\n\ntype EdgePosition = {\n  type: 'line';\n  sourcePosition: [number, number];\n  targetPosition: [number, number];\n  controlPoints: [];\n};\n\nexport class RandomLayout extends GraphLayout<RandomLayoutProps> {\n  static readonly defaultProps: RandomLayoutProps = {\n    viewportWidth: 1024,\n    viewportHeight: 768\n  };\n\n  protected override readonly _name = 'RandomLayout';\n\n  private graph: ClassicGraph | null = null;\n  private nodePositions = new Map<string | number, [number, number]>();\n\n  constructor(props: RandomLayoutProps = RandomLayout.defaultProps) {\n    super(props, RandomLayout.defaultProps);\n  }\n\n  initializeGraph(graph: ClassicGraph): void {\n    this.updateGraph(graph);\n  }\n\n  updateGraph(graph: ClassicGraph): void {\n    this.graph = graph;\n    const nextPositions = new Map<string | number, [number, number]>();\n\n    for (const node of graph.getNodes()) {\n      const nodeId = node.getId();\n      const previous = this.nodePositions.get(nodeId) ?? [0, 0];\n      nextPositions.set(nodeId, previous);\n    }\n\n    this.nodePositions = nextPositions;\n  }\n\n  start(): void {\n    this._runLayout();\n  }\n\n  update(): void {\n    this._runLayout();\n  }\n\n  resume(): void {\n    this._runLayout();\n  }\n\n  stop(): void {}\n\n  getNodePosition(node: NodeInterface): [number, number] | null {\n    return this.nodePositions.get(node.getId()) ?? null;\n  }\n\n  getEdgePosition(edge: EdgeInterface): EdgePosition {\n    const sourcePosition = this.nodePositions.get(edge.getSourceNodeId()) ?? [0, 0];\n    const targetPosition = this.nodePositions.get(edge.getTargetNodeId()) ?? [0, 0];\n\n    return {\n      type: 'line',\n      sourcePosition,\n      targetPosition,\n      controlPoints: []\n    };\n  }\n\n  lockNodePosition(node: NodeInterface, x: number, y: number): void {\n    this.nodePositions.set(node.getId(), [x, y]);\n    this._onLayoutChange();\n  }\n\n  unlockNodePosition(node: NodeInterface): void {\n    this.nodePositions.delete(node.getId());\n    this._onLayoutChange();\n  }\n\n  protected override _updateBounds(): void {\n    this._bounds = this._calculateBounds(this.nodePositions.values());\n  }\n\n  private _runLayout(): void {\n    if (!this.graph) {\n      return;\n    }\n\n    this._onLayoutStart();\n    this._randomizePositions();\n    this._onLayoutChange();\n    this._onLayoutDone();\n  }\n\n  private _randomizePositions(): void {\n    const {viewportWidth, viewportHeight} = this.props;\n\n    for (const nodeId of this.nodePositions.keys()) {\n      this.nodePositions.set(nodeId, [\n        Math.random() * viewportWidth,\n        Math.random() * viewportHeight\n      ]);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"the-layout-lifecycle",children:"The layout lifecycle"}),"\n",(0,s.jsx)(n.p,{children:"Graph layouts respond to graph mutations and user interactions through a small set of lifecycle methods and helper utilities."}),"\n",(0,s.jsx)(n.h3,{id:"lifecycle-phases",children:"Lifecycle phases"}),"\n",(0,s.jsx)(n.p,{children:"A layout transitions through the following phases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mounting"})," \u2013 ",(0,s.jsx)(n.code,{children:"constructor"})," \u2192 ",(0,s.jsx)(n.code,{children:"initializeGraph"})," \u2192 ",(0,s.jsx)(n.code,{children:"start"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Updating"})," \u2013 ",(0,s.jsx)(n.code,{children:"updateGraph"})," \u2192 ",(0,s.jsx)(n.code,{children:"update"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interruption"})," \u2013 ",(0,s.jsx)(n.code,{children:"stop"})," halts any active run, while ",(0,s.jsx)(n.code,{children:"resume"})," should restart computation (typically by calling ",(0,s.jsx)(n.code,{children:"start"}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"emitting-layout-events",children:"Emitting layout events"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"GraphLayout"})," exposes ",(0,s.jsx)(n.code,{children:"_onLayoutStart"}),", ",(0,s.jsx)(n.code,{children:"_onLayoutChange"}),", ",(0,s.jsx)(n.code,{children:"_onLayoutDone"}),", and ",(0,s.jsx)(n.code,{children:"_onLayoutError"})," helpers that notify ",(0,s.jsx)(n.code,{children:"GraphLayer"})," and any user-supplied callbacks. Use them to surface progress:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"_onLayoutStart"})," before you begin a fresh computation cycle. This transitions the internal state to ",(0,s.jsx)(n.code,{children:"calculating"})," and sends the current bounds to listeners."]}),"\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"_onLayoutChange"})," after every iteration that mutates node or edge positions. Invoking this method multiple times during a single run is expected when the layout updates incrementally."]}),"\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"_onLayoutDone"})," once an iteration completes and no further updates are pending. This sets the internal state to ",(0,s.jsx)(n.code,{children:"done"})," and re-emits the latest bounds."]}),"\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"_onLayoutError"})," when the layout cannot continue (e.g. due to invalid data or an exception)."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"graphlayouteventdetail",children:"GraphLayoutEventDetail"}),"\n",(0,s.jsxs)(n.p,{children:["All lifecycle callbacks receive a ",(0,s.jsx)(n.code,{children:"GraphLayoutEventDetail"})," object containing the latest ",(0,s.jsx)(n.code,{children:"{bounds}"})," calculated by the layout:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type GraphLayoutEventDetail = {\n  bounds: [[number, number], [number, number]] | null;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Bounds follow the ",(0,s.jsx)(n.a,{href:"https://github.com/uber-web/math.gl/blob/master/modules/types/docs/api-reference/bounds.md",children:(0,s.jsx)(n.code,{children:"Bounds2D"})})," tuple format ",(0,s.jsx)(n.code,{children:"[[minX, minY], [maxX, maxY]]"}),". You can also call ",(0,s.jsx)(n.code,{children:"layout.getBounds()"})," at any time to retrieve the same values."]}),"\n",(0,s.jsx)(n.h3,{id:"maintaining-layout-bounds",children:"Maintaining layout bounds"}),"\n",(0,s.jsxs)(n.p,{children:["Override ",(0,s.jsx)(n.code,{children:"_updateBounds"})," to keep ",(0,s.jsx)(n.code,{children:"_bounds"})," in sync with your layout state. Most layouts only need to funnel their node positions through ",(0,s.jsx)(n.code,{children:"_calculateBounds"}),", which filters out non-finite coordinates before producing the enclosing rectangle. Update bounds ",(0,s.jsx)(n.strong,{children:"before"})," each event emission so callbacks receive the freshest extent information."]}),"\n",(0,s.jsx)(n.h3,{id:"drag-interactions",children:"Drag interactions"}),"\n",(0,s.jsx)(n.p,{children:"To support drag-and-drop interactions:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"lockNodePosition"})," when a drag starts to pin the node."]}),"\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"unlockNodePosition"})," after releasing the pointer."]}),"\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"resume"})," to restart the layout if it needs to continue processing after the drag completes."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A typical sequence looks like ",(0,s.jsx)(n.code,{children:"startDragging \u2192 lockNodePosition \u2192 release \u2192 unlockNodePosition \u2192 resume"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"accessors",children:"Accessors"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"GraphLayout"})," repeatedly calls ",(0,s.jsx)(n.code,{children:"getNodePosition"})," and ",(0,s.jsx)(n.code,{children:"getEdgePosition"})," to fetch the latest geometry:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getNodePosition(node)"})," returns the node position ",(0,s.jsx)(n.code,{children:"[x, y]"}),". Return ",(0,s.jsx)(n.code,{children:"null"})," when a position is unavailable to hide the node until the layout resolves it."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getEdgePosition(edge)"})," returns rendering information for an edge, including:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"type"}),": the edge primitive (",(0,s.jsx)(n.code,{children:"'line'"}),", ",(0,s.jsx)(n.code,{children:"'spline-curve'"}),", or ",(0,s.jsx)(n.code,{children:"'path'"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sourcePosition"}),"/",(0,s.jsx)(n.code,{children:"targetPosition"}),": coordinates for the edge endpoints."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"controlPoints"}),": optional control points for curved or multi-segment edges."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Ensure these methods always return consistent data for the current layout state."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},43456:e=>{e.exports=JSON.parse('{"id":"modules/graph-layers/api-reference/layouts/graph-layout","title":"GraphLayout","description":"Create a subclass of the GraphLayout class to implement a custom layout for the GraphLayer.","source":"@site/../docs/modules/graph-layers/api-reference/layouts/graph-layout.md","sourceDirName":"modules/graph-layers/api-reference/layouts","slug":"/modules/graph-layers/api-reference/layouts/graph-layout","permalink":"/deck.gl-community/docs/modules/graph-layers/api-reference/layouts/graph-layout","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/deck.gl-community/tree/master/website/../docs/modules/graph-layers/api-reference/layouts/graph-layout.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"SimpleLayout","permalink":"/deck.gl-community/docs/modules/graph-layers/api-reference/layouts/simple-layout"},"next":{"title":"D3ForceLayout","permalink":"/deck.gl-community/docs/modules/graph-layers/api-reference/layouts/d3-force-layout"}}')}}]);