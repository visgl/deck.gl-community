"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[2752],{7769:(t,e,o)=>{o.d(e,{A:()=>m});var n=o(9350),i=o(46487),r=o(84175),s=o(83895),a=o(67118),c=o(33027),l=o(25337),p=o(82491),u=o(90138),d=o(64496),h=o(30170);const g={getSourcePosition:{type:"accessor",value:t=>t.sourcePosition},getTargetPosition:{type:"accessor",value:t=>t.targetPosition},getColor:{type:"accessor",value:[0,0,0,255]},getWidth:{type:"accessor",value:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class f extends a.A{getBounds(){return this.getAttributeManager()?.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:d.A,fs:h.A,source:u.T,modules:[r.A,i.A,s.A,p.U]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:[0,0,0,255]},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1}})}updateState(t){super.updateState(t),t.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:t}){const{widthUnits:e,widthScale:o,widthMinPixels:i,widthMaxPixels:r,wrapLongitude:s}=this.props,a=this.state.model,c={widthUnits:n.p5[e],widthScale:o,widthMinPixels:i,widthMaxPixels:r,useShortestPath:s?1:0};a.shaderInputs.setProps({line:c}),a.draw(this.context.renderPass),s&&(a.shaderInputs.setProps({line:{...c,useShortestPath:-1}}),a.draw(this.context.renderPass))}_getModel(){const t="webgpu"===this.context.device.type?{depthWriteEnabled:!0,depthCompare:"less-equal"}:void 0;return new c.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new l.V({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array([0,-1,0,0,1,0,1,-1,0,1,1,0])}}}),parameters:t,isInstanced:!0})}}f.layerName="LineLayer",f.defaultProps=g;const m=f},27698:(t,e,o)=>{o.d(e,{c:()=>a});var n=o(54901),i=o(94717),r=o(60676),s=o(25667);o(70053);class a extends r.A{constructor(t){const{width:e,height:o,rotationX:n=0,rotationOrbit:i=0,target:r=[0,0,0],zoom:s=0,minRotationX:a=-90,maxRotationX:c=90,minZoom:l=-1/0,maxZoom:p=1/0,startPanPosition:u,startRotatePos:d,startRotationX:h,startRotationOrbit:g,startZoomPosition:f,startZoom:m}=t;super({width:e,height:o,rotationX:n,rotationOrbit:i,target:r,zoom:s,minRotationX:a,maxRotationX:c,minZoom:l,maxZoom:p},{startPanPosition:u,startRotatePos:d,startRotationX:h,startRotationOrbit:g,startZoomPosition:f,startZoom:m}),this.makeViewport=t.makeViewport}panStart({pos:t}){return this._getUpdatedState({startPanPosition:this._unproject(t)})}pan({pos:t,startPosition:e}){const o=this.getState().startPanPosition||e;if(!o)return this;const n=this.makeViewport(this.getViewportProps()).panByPosition(o,t);return this._getUpdatedState(n)}panEnd(){return this._getUpdatedState({startPanPosition:null})}rotateStart({pos:t}){return this._getUpdatedState({startRotatePos:t,startRotationX:this.getViewportProps().rotationX,startRotationOrbit:this.getViewportProps().rotationOrbit})}rotate({pos:t,deltaAngleX:e=0,deltaAngleY:o=0}){const{startRotatePos:n,startRotationX:i,startRotationOrbit:r}=this.getState(),{width:s,height:a}=this.getViewportProps();if(!n||void 0===i||void 0===r)return this;let c;if(t){let e=(t[0]-n[0])/s;(i<-90||i>90)&&(e*=-1),c={rotationX:i+180*((t[1]-n[1])/a),rotationOrbit:r+180*e}}else c={rotationX:i+o,rotationOrbit:r+e};return this._getUpdatedState(c)}rotateEnd(){return this._getUpdatedState({startRotationX:null,startRotationOrbit:null})}shortestPathFrom(t){const e=t.getViewportProps(),o={...this.getViewportProps()},{rotationOrbit:n}=o;return Math.abs(n-e.rotationOrbit)>180&&(o.rotationOrbit=n<0?n+360:n-360),o}zoomStart({pos:t}){return this._getUpdatedState({startZoomPosition:this._unproject(t),startZoom:this.getViewportProps().zoom})}zoom({pos:t,startPos:e,scale:o}){let{startZoom:n,startZoomPosition:i}=this.getState();if(i||(n=this.getViewportProps().zoom,i=this._unproject(e)||this._unproject(t)),!i)return this;const r=this._calculateNewZoom({scale:o,startZoom:n}),s=this.makeViewport({...this.getViewportProps(),zoom:r});return this._getUpdatedState({zoom:r,...s.panByPosition(i,t)})}zoomEnd(){return this._getUpdatedState({startZoomPosition:null,startZoom:null})}zoomIn(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:t})})}zoomOut(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:1/t})})}moveLeft(t=50){return this._panFromCenter([-t,0])}moveRight(t=50){return this._panFromCenter([t,0])}moveUp(t=50){return this._panFromCenter([0,-t])}moveDown(t=50){return this._panFromCenter([0,t])}rotateLeft(t=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit-t})}rotateRight(t=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit+t})}rotateUp(t=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX-t})}rotateDown(t=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX+t})}_unproject(t){const e=this.makeViewport(this.getViewportProps());return t&&e.unproject(t)}_calculateNewZoom({scale:t,startZoom:e}){const{maxZoom:o,minZoom:i}=this.getViewportProps();void 0===e&&(e=this.getViewportProps().zoom);const r=e+Math.log2(t);return(0,n.qE)(r,i,o)}_panFromCenter(t){const{width:e,height:o,target:n}=this.getViewportProps();return this.pan({startPosition:n,pos:[e/2+t[0],o/2+t[1]]})}_getUpdatedState(t){return new this.constructor({makeViewport:this.makeViewport,...this.getViewportProps(),...this.getState(),...t})}applyConstraints(t){const{maxZoom:e,minZoom:o,zoom:i,maxRotationX:r,minRotationX:a,rotationOrbit:c}=t;return t.zoom=Array.isArray(i)?[(0,n.qE)(i[0],o,e),(0,n.qE)(i[1],o,e)]:(0,n.qE)(i,o,e),t.rotationX=(0,n.qE)(t.rotationX,a,r),(c<-180||c>180)&&(t.rotationOrbit=(0,s.zi)(c+180,360)-180),t}}i.A},30170:(t,e,o)=>{o.d(e,{A:()=>n});const n="#version 300 es\n#define SHADER_NAME line-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 uv;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = uv;\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n"},53374:(t,e,o)=>{o.d(e,{A:()=>a});var n=o(17393),i=o(95896),r=o(54024);class s extends n.A{constructor(t={}){super(t)}getViewportType(){return i.A}get ControllerType(){return r.A}}s.displayName="OrthographicView";const a=s},54024:(t,e,o)=>{o.d(e,{A:()=>c});var n=o(54901),i=o(94717),r=o(27698),s=o(70053);class a extends r.c{constructor(t){super(t),this.zoomAxis=t.zoomAxis||"all"}_calculateNewZoom({scale:t,startZoom:e}){const{maxZoom:o,minZoom:i}=this.getViewportProps();void 0===e&&(e=this.getViewportProps().zoom);let r=Math.log2(t);if(Array.isArray(e)){let[t,s]=e;switch(this.zoomAxis){case"X":t=(0,n.qE)(t+r,i,o);break;case"Y":s=(0,n.qE)(s+r,i,o);break;default:let e=Math.min(t+r,s+r);e<i&&(r+=i-e),e=Math.max(t+r,s+r),e>o&&(r+=o-e),t+=r,s+=r}return[t,s]}return(0,n.qE)(e+r,i,o)}}class c extends i.A{constructor(){super(...arguments),this.ControllerState=a,this.transition={transitionDuration:300,transitionInterpolator:new s.A(["target","zoom"])},this.dragMode="pan"}_onPanRotate(){return!1}}},64496:(t,e,o)=>{o.d(e,{A:()=>n});const n="#version 300 es\n#define SHADER_NAME line-layer-vertex-shader\nin vec3 positions;\nin vec3 instanceSourcePositions;\nin vec3 instanceTargetPositions;\nin vec3 instanceSourcePositions64Low;\nin vec3 instanceTargetPositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin float instanceWidths;\nout vec4 vColor;\nout vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\nvec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);\ndir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\nreturn dir_screenspace * offset_direction * width / 2.0;\n}\nvec3 splitLine(vec3 a, vec3 b, float x) {\nfloat t = (x - a.x) / (b.x - a.x);\nreturn vec3(x, mix(a.yz, b.yz, t));\n}\nvoid main(void) {\ngeometry.worldPosition = instanceSourcePositions;\ngeometry.worldPositionAlt = instanceTargetPositions;\nvec3 source_world = instanceSourcePositions;\nvec3 target_world = instanceTargetPositions;\nvec3 source_world_64low = instanceSourcePositions64Low;\nvec3 target_world_64low = instanceTargetPositions64Low;\nif (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {\nsource_world.x = mod(source_world.x + 180., 360.0) - 180.;\ntarget_world.x = mod(target_world.x + 180., 360.0) - 180.;\nfloat deltaLng = target_world.x - source_world.x;\nif (deltaLng * line.useShortestPath > 180.) {\nsource_world.x += 360. * line.useShortestPath;\nsource_world = splitLine(source_world, target_world, 180. * line.useShortestPath);\nsource_world_64low = vec3(0.0);\n} else if (deltaLng * line.useShortestPath < -180.) {\ntarget_world.x += 360. * line.useShortestPath;\ntarget_world = splitLine(source_world, target_world, 180. * line.useShortestPath);\ntarget_world_64low = vec3(0.0);\n} else if (line.useShortestPath < 0.) {\ngl_Position = vec4(0.);\nreturn;\n}\n}\nvec4 source_commonspace;\nvec4 target_commonspace;\nvec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\nvec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\nfloat segmentIndex = positions.x;\nvec4 p = mix(source, target, segmentIndex);\ngeometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\nuv = positions.xy;\ngeometry.uv = uv;\ngeometry.pickingColor = instancePickingColors;\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),\nline.widthMinPixels, line.widthMaxPixels\n);\nvec3 offset = vec3(\ngetExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\nDECKGL_FILTER_GL_POSITION(p, geometry);\ngl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\nvColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n"},82491:(t,e,o)=>{o.d(e,{U:()=>i});const n="uniform lineUniforms {\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  float useShortestPath;\n  highp int widthUnits;\n} line;\n",i={name:"line",source:"struct LineUniforms {\n  widthScale: f32,\n  widthMinPixels: f32,\n  widthMaxPixels: f32,\n  useShortestPath: f32,\n  widthUnits: i32,\n};\n\n@group(0) @binding(1)\nvar<uniform> line: LineUniforms;\n",vs:n,fs:n,uniformTypes:{widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",useShortestPath:"f32",widthUnits:"i32"}}},90138:(t,e,o)=>{o.d(e,{T:()=>n});const n='// ---------- Helper Structures & Functions ----------\n\n// Placeholder filter functions.\nfn deckgl_filter_size(offset: vec3<f32>, geometry: Geometry) -> vec3<f32> {\n  return offset;\n}\nfn deckgl_filter_gl_position(p: vec4<f32>, geometry: Geometry) -> vec4<f32> {\n  return p;\n}\nfn deckgl_filter_color(color: vec4<f32>, geometry: Geometry) -> vec4<f32> {\n  return color;\n}\n\n// Compute an extrusion offset given a line direction (in clipspace),\n// an offset direction (-1 or 1), and a width in pixels.\n// Assumes a uniform "project" with a viewportSize field is available.\nfn getExtrusionOffset(line_clipspace: vec2<f32>, offset_direction: f32, width: f32) -> vec2<f32> {\n  // project.viewportSize should be provided as a uniform (not shown here)\n  let dir_screenspace = normalize(line_clipspace * project.viewportSize);\n  // Rotate by 90\xb0: (x,y) becomes (-y,x)\n  let rotated = vec2<f32>(-dir_screenspace.y, dir_screenspace.x);\n  return rotated * offset_direction * width / 2.0;\n}\n\n// Splits the line between two points at a given x coordinate.\n// Interpolates the y and z components.\nfn splitLine(a: vec3<f32>, b: vec3<f32>, x: f32) -> vec3<f32> {\n  let t: f32 = (x - a.x) / (b.x - a.x);\n  return vec3<f32>(x, a.yz + t * (b.yz - a.yz));\n}\n\n// ---------- Uniforms & Global Structures ----------\n\n// Uniforms for line, color, and project are assumed to be defined elsewhere.\n// For example:\n//\n// @group(0) @binding(0)\n// var<uniform> line: LineUniform;\n//\n// struct ColorUniform {\n//   opacity: f32,\n// };\n// @group(0) @binding(1)\n// var<uniform> color: ColorUniform;\n//\n// struct ProjectUniform {\n//   viewportSize: vec2<f32>,\n// };\n// @group(0) @binding(2)\n// var<uniform> project: ProjectUniform;\n\n\n\n// ---------- Vertex Output Structure ----------\n\nstruct Varyings {\n  @builtin(position) gl_Position: vec4<f32>,\n  @location(0) vColor: vec4<f32>,\n  @location(1) uv: vec2<f32>,\n};\n\n// ---------- Vertex Shader Entry Point ----------\n\n@vertex\nfn vertexMain(\n  @location(0) positions: vec3<f32>,\n  @location(1) instanceSourcePositions: vec3<f32>,\n  @location(2) instanceTargetPositions: vec3<f32>,\n  @location(3) instanceSourcePositions64Low: vec3<f32>,\n  @location(4) instanceTargetPositions64Low: vec3<f32>,\n  @location(5) instanceColors: vec4<f32>,\n  @location(6) instancePickingColors: vec3<f32>,\n  @location(7) instanceWidths: f32\n) -> Varyings {\n  var geometry: Geometry;\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  var source_world: vec3<f32> = instanceSourcePositions;\n  var target_world: vec3<f32> = instanceTargetPositions;\n  var source_world_64low: vec3<f32> = instanceSourcePositions64Low;\n  var target_world_64low: vec3<f32> = instanceTargetPositions64Low;\n\n  // Apply shortest-path adjustments if needed.\n  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {\n    source_world.x = (source_world.x + 180.0 % 360.0) - 180.0;\n    target_world.x = (target_world.x + 180.0 % 360.0) - 180.0;\n    let deltaLng: f32 = target_world.x - source_world.x;\n\n    if (deltaLng * line.useShortestPath > 180.0) {\n      source_world.x = source_world.x + 360.0 * line.useShortestPath;\n      source_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);\n      source_world_64low = vec3<f32>(0.0, 0.0, 0.0);\n    } else if (deltaLng * line.useShortestPath < -180.0) {\n      target_world.x = target_world.x + 360.0 * line.useShortestPath;\n      target_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);\n      target_world_64low = vec3<f32>(0.0, 0.0, 0.0);\n    } else if (line.useShortestPath < 0.0) {\n      var abortOut: Varyings;\n      abortOut.gl_Position = vec4<f32>(0.0);\n      abortOut.vColor = vec4<f32>(0.0);\n      abortOut.uv = vec2<f32>(0.0);\n      return abortOut;\n    }\n  }\n\n  // Project Pos and target positions to clip space.\n  let sourceResult = project_position_to_clipspace_and_commonspace(source_world, source_world_64low, vec3<f32>(0.0));\n  let targetResult = project_position_to_clipspace_and_commonspace(target_world, target_world_64low, vec3<f32>(0.0));\n  let sourcePos: vec4<f32> = sourceResult.clipPosition;\n  let targetPos: vec4<f32> = targetResult.clipPosition;\n  let source_commonspace: vec4<f32> = sourceResult.commonPosition;\n  let target_commonspace: vec4<f32> = targetResult.commonPosition;\n\n  // Interpolate along the line segment.\n  let segmentIndex: f32 = positions.x;\n  let p: vec4<f32> = sourcePos + segmentIndex * (targetPos - sourcePos);\n  geometry.position = source_commonspace + segmentIndex * (target_commonspace - source_commonspace);\n  let uv: vec2<f32> = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  // Determine width in pixels.\n  let widthPixels: f32 = clamp(\n    project_unit_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),\n    line.widthMinPixels, line.widthMaxPixels\n  );\n\n  // Compute extrusion offset.\n  let extrusion: vec2<f32> = getExtrusionOffset(targetPos.xy - sourcePos.xy, positions.y, widthPixels);\n  let offset: vec3<f32> = vec3<f32>(extrusion, 0.0);\n\n  // Apply deck.gl filter functions.\n  let filteredOffset = deckgl_filter_size(offset, geometry);\n  let filteredP = deckgl_filter_gl_position(p, geometry);\n\n  let clipOffset: vec2<f32> = project_pixel_size_to_clipspace(filteredOffset.xy);\n  let finalPosition: vec4<f32> = filteredP + vec4<f32>(clipOffset, 0.0, 0.0);\n\n  // Compute color.\n  var vColor: vec4<f32> = vec4<f32>(instanceColors.rgb, instanceColors.a * color.opacity);\n  // vColor = deckgl_filter_color(vColor, geometry);\n\n  var output: Varyings;\n  output.gl_Position = finalPosition;\n  output.vColor = vColor;\n  output.uv = uv;\n  return output;\n}\n\n@fragment\nfn fragmentMain(\n  @location(0) vColor: vec4<f32>,\n  @location(1) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n  // Create and initialize geometry with the provided uv.\n  var geometry: Geometry;\n  geometry.uv = uv;\n\n  // Start with the input color.\n  var fragColor: vec4<f32> = vColor;\n\n  // Apply the deck.gl filter to the color.\n  fragColor = deckgl_filter_color(fragColor, geometry);\n\n  // Apply premultiplied alpha as required by transparent canvas\n  fragColor = deckgl_premultiplied_alpha(fragColor);\n\n  return fragColor;\n}\n'},95896:(t,e,o)=>{o.d(e,{A:()=>p});var n=o(47345),i=o(31886),r=o(54901),s=o(83588),a=o(73279);const c=(new i.k).lookAt({eye:[0,0,1]});function l({width:t,height:e,near:o,far:n,padding:s}){let a=-t/2,c=t/2,l=-e/2,p=e/2;if(s){const{left:o=0,right:n=0,top:i=0,bottom:u=0}=s,d=(0,r.qE)((o+t-n)/2,0,t)-t/2,h=(0,r.qE)((i+e-u)/2,0,e)-e/2;a-=d,c-=d,l+=h,p+=h}return(new i.k).ortho({left:a,right:c,bottom:l,top:p,near:o,far:n})}class p extends n.A{constructor(t){const{width:e,height:o,near:n=.1,far:i=1e3,zoom:r=0,target:s=[0,0,0],padding:a=null,flipY:p=!0}=t,u=Array.isArray(r)?r[0]:r,d=Array.isArray(r)?r[1]:r,h=Math.min(u,d),g=Math.pow(2,h);let f;if(u!==d){const t=Math.pow(2,u),e=Math.pow(2,d);f={unitsPerMeter:[t/g,e/g,1],metersPerUnit:[g/t,g/e,1]}}super({...t,longitude:void 0,position:s,viewMatrix:c.clone().scale([g,g*(p?-1:1),g]),projectionMatrix:l({width:e||1,height:o||1,padding:a,near:n,far:i}),zoom:h,distanceScales:f})}projectFlat([t,e]){const{unitsPerMeter:o}=this.distanceScales;return[t*o[0],e*o[1]]}unprojectFlat([t,e]){const{metersPerUnit:o}=this.distanceScales;return[t*o[0],e*o[1]]}panByPosition(t,e){const o=(0,a.xJ)(e,this.pixelUnprojectionMatrix),n=this.projectFlat(t),i=s.WQ([],n,s.ze([],o)),r=s.WQ([],this.center,i);return{target:this.unprojectFlat(r)}}}}}]);