"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5846],{10201:(t,i,e)=>{e.d(i,{FD:()=>s,FK:()=>n.FK,Y:()=>s});var n=e(50172);var o=0;Array.isArray;function s(t,i,e,s,r,a){i||(i={});var l,c,d=i;if("ref"in d)for(c in d={},i)"ref"==c?l=i[c]:d[c]=i[c];var p={type:t,props:d,key:e,ref:l,__k:null,__:null,__b:0,__e:null,__c:null,constructor:void 0,__v:--o,__i:-1,__u:0,__source:r,__self:a};if("function"==typeof t&&(l=t.defaultProps))for(c in l)void 0===d[c]&&(d[c]=l[c]);return n.fF.vnode&&n.fF.vnode(p),p}},12228:(t,i,e)=>{e.d(i,{A:()=>n});const n="// Main shaders\n\nstruct ScatterplotUniforms {\n  radiusScale: f32,\n  radiusMinPixels: f32,\n  radiusMaxPixels: f32,\n  lineWidthScale: f32,\n  lineWidthMinPixels: f32,\n  lineWidthMaxPixels: f32,\n  stroked: f32,\n  filled: i32,\n  antialiasing: i32,\n  billboard: i32,\n  radiusUnits: i32,\n  lineWidthUnits: i32,\n};\n\nstruct ConstantAttributeUniforms {\n instancePositions: vec3<f32>,\n instancePositions64Low: vec3<f32>,\n instanceRadius: f32,\n instanceLineWidths: f32,\n instanceFillColors: vec4<f32>,\n instanceLineColors: vec4<f32>,\n instancePickingColors: vec3<f32>,\n\n instancePositionsConstant: i32,\n instancePositions64LowConstant: i32,\n instanceRadiusConstant: i32,\n instanceLineWidthsConstant: i32,\n instanceFillColorsConstant: i32,\n instanceLineColorsConstant: i32,\n instancePickingColorsConstant: i32\n};\n\n@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;\n\nstruct ConstantAttributes {\n  instancePositions: vec3<f32>,\n  instancePositions64Low: vec3<f32>,\n  instanceRadius: f32,\n  instanceLineWidths: f32,\n  instanceFillColors: vec4<f32>,\n  instanceLineColors: vec4<f32>,\n  instancePickingColors: vec3<f32>\n};\n\nconst constants = ConstantAttributes(\n  vec3<f32>(0.0),\n  vec3<f32>(0.0),\n  0.0,\n  0.0,\n  vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  vec3<f32>(0.0)\n);\n\nstruct Attributes {\n  @builtin(instance_index) instanceIndex : u32,\n  @builtin(vertex_index) vertexIndex : u32,\n  @location(0) positions: vec3<f32>,\n  @location(1) instancePositions: vec3<f32>,\n  @location(2) instancePositions64Low: vec3<f32>,\n  @location(3) instanceRadius: f32,\n  @location(4) instanceLineWidths: f32,\n  @location(5) instanceFillColors: vec4<f32>,\n  @location(6) instanceLineColors: vec4<f32>,\n  @location(7) instancePickingColors: vec3<f32>\n};\n\nstruct Varyings {\n  @builtin(position) position: vec4<f32>,\n  @location(0) vFillColor: vec4<f32>,\n  @location(1) vLineColor: vec4<f32>,\n  @location(2) unitPosition: vec2<f32>,\n  @location(3) innerUnitRadius: f32,\n  @location(4) outerRadiusPixels: f32,\n};\n\n@vertex\nfn vertexMain(attributes: Attributes) -> Varyings {\n  var varyings: Varyings;\n\n  // Draw an inline geometry constant array clip space triangle to verify that rendering works.\n  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));\n  // if (attributes.instanceIndex == 0) {\n  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);\n  //   return varyings;\n  // }\n\n  // var geometry: Geometry;\n  // geometry.worldPosition = instancePositions;\n\n  // Multiply out radius and clamp to limits\n  varyings.outerRadiusPixels = clamp(\n    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),\n    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels\n  );\n\n  // Multiply out line width and clamp to limits\n  let lineWidthPixels = clamp(\n    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),\n    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;\n  // Expand geometry to accommodate edge smoothing\n  let edgePadding = select(\n    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,\n    1.0,\n    scatterplot.antialiasing != 0\n  );\n\n  // position on the containing square in [-1, 1] space\n  varyings.unitPosition = edgePadding * attributes.positions.xy;\n  geometry.uv = varyings.unitPosition;\n  geometry.pickingColor = attributes.instancePickingColors;\n\n  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;\n\n  if (scatterplot.billboard != 0) {\n    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);\n    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);\n    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;\n    // DECKGL_FILTER_SIZE(offset, geometry);\n    let clipPixels = project_pixel_size_to_clipspace(offset.xy);\n    varyings.position.x = clipPixels.x;\n    varyings.position.y = clipPixels.y;\n  } else {\n    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);\n    // DECKGL_FILTER_SIZE(offset, geometry);\n    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);\n    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);\n  }\n\n  // Apply opacity to instance color, or return instance picking color\n  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * color.opacity);\n  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);\n  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * color.opacity);\n  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);\n\n  return varyings;\n}\n\n@fragment\nfn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {\n  // var geometry: Geometry;\n  // geometry.uv = unitPosition;\n\n  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;\n  let inCircle = select(\n    smoothedge(distToCenter, varyings.outerRadiusPixels),\n    step(distToCenter, varyings.outerRadiusPixels),\n    scatterplot.antialiasing != 0\n  );\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  var fragColor: vec4<f32>;\n\n  if (scatterplot.stroked != 0) {\n    let isLine = select(\n      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),\n      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),\n      scatterplot.antialiasing != 0\n    );\n\n    if (scatterplot.filled != 0) {\n      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);\n    }\n  } else if (scatterplot.filled == 0) {\n    discard;\n  } else {\n    fragColor = varyings.vFillColor;\n  }\n\n  fragColor.a *= inCircle;\n  // DECKGL_FILTER_COLOR(fragColor, geometry);\n\n  // Apply premultiplied alpha as required by transparent canvas\n  fragColor = deckgl_premultiplied_alpha(fragColor);\n\n  return fragColor;\n  // return vec4<f32>(0, 0, 1, 1);\n}\n"},27698:(t,i,e)=>{e.d(i,{c:()=>a});var n=e(54901),o=e(94717),s=e(60676),r=e(25667);e(70053);class a extends s.A{constructor(t){const{width:i,height:e,rotationX:n=0,rotationOrbit:o=0,target:s=[0,0,0],zoom:r=0,minRotationX:a=-90,maxRotationX:l=90,minZoom:c=-1/0,maxZoom:d=1/0,startPanPosition:p,startRotatePos:u,startRotationX:g,startRotationOrbit:h,startZoomPosition:f,startZoom:m}=t;super({width:i,height:e,rotationX:n,rotationOrbit:o,target:s,zoom:r,minRotationX:a,maxRotationX:l,minZoom:c,maxZoom:d},{startPanPosition:p,startRotatePos:u,startRotationX:g,startRotationOrbit:h,startZoomPosition:f,startZoom:m}),this.makeViewport=t.makeViewport}panStart({pos:t}){return this._getUpdatedState({startPanPosition:this._unproject(t)})}pan({pos:t,startPosition:i}){const e=this.getState().startPanPosition||i;if(!e)return this;const n=this.makeViewport(this.getViewportProps()).panByPosition(e,t);return this._getUpdatedState(n)}panEnd(){return this._getUpdatedState({startPanPosition:null})}rotateStart({pos:t}){return this._getUpdatedState({startRotatePos:t,startRotationX:this.getViewportProps().rotationX,startRotationOrbit:this.getViewportProps().rotationOrbit})}rotate({pos:t,deltaAngleX:i=0,deltaAngleY:e=0}){const{startRotatePos:n,startRotationX:o,startRotationOrbit:s}=this.getState(),{width:r,height:a}=this.getViewportProps();if(!n||void 0===o||void 0===s)return this;let l;if(t){let i=(t[0]-n[0])/r;(o<-90||o>90)&&(i*=-1),l={rotationX:o+180*((t[1]-n[1])/a),rotationOrbit:s+180*i}}else l={rotationX:o+e,rotationOrbit:s+i};return this._getUpdatedState(l)}rotateEnd(){return this._getUpdatedState({startRotationX:null,startRotationOrbit:null})}shortestPathFrom(t){const i=t.getViewportProps(),e={...this.getViewportProps()},{rotationOrbit:n}=e;return Math.abs(n-i.rotationOrbit)>180&&(e.rotationOrbit=n<0?n+360:n-360),e}zoomStart({pos:t}){return this._getUpdatedState({startZoomPosition:this._unproject(t),startZoom:this.getViewportProps().zoom})}zoom({pos:t,startPos:i,scale:e}){let{startZoom:n,startZoomPosition:o}=this.getState();if(o||(n=this.getViewportProps().zoom,o=this._unproject(i)||this._unproject(t)),!o)return this;const s=this._calculateNewZoom({scale:e,startZoom:n}),r=this.makeViewport({...this.getViewportProps(),zoom:s});return this._getUpdatedState({zoom:s,...r.panByPosition(o,t)})}zoomEnd(){return this._getUpdatedState({startZoomPosition:null,startZoom:null})}zoomIn(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:t})})}zoomOut(t=2){return this._getUpdatedState({zoom:this._calculateNewZoom({scale:1/t})})}moveLeft(t=50){return this._panFromCenter([-t,0])}moveRight(t=50){return this._panFromCenter([t,0])}moveUp(t=50){return this._panFromCenter([0,-t])}moveDown(t=50){return this._panFromCenter([0,t])}rotateLeft(t=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit-t})}rotateRight(t=15){return this._getUpdatedState({rotationOrbit:this.getViewportProps().rotationOrbit+t})}rotateUp(t=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX-t})}rotateDown(t=10){return this._getUpdatedState({rotationX:this.getViewportProps().rotationX+t})}_unproject(t){const i=this.makeViewport(this.getViewportProps());return t&&i.unproject(t)}_calculateNewZoom({scale:t,startZoom:i}){const{maxZoom:e,minZoom:o}=this.getViewportProps();void 0===i&&(i=this.getViewportProps().zoom);const s=i+Math.log2(t);return(0,n.qE)(s,o,e)}_panFromCenter(t){const{width:i,height:e,target:n}=this.getViewportProps();return this.pan({startPosition:n,pos:[i/2+t[0],e/2+t[1]]})}_getUpdatedState(t){return new this.constructor({makeViewport:this.makeViewport,...this.getViewportProps(),...this.getState(),...t})}applyConstraints(t){const{maxZoom:i,minZoom:e,zoom:o,maxRotationX:s,minRotationX:a,rotationOrbit:l}=t;return t.zoom=Array.isArray(o)?[(0,n.qE)(o[0],e,i),(0,n.qE)(o[1],e,i)]:(0,n.qE)(o,e,i),t.rotationX=(0,n.qE)(t.rotationX,a,s),(l<-180||l>180)&&(t.rotationOrbit=(0,r.zi)(l+180,360)-180),t}}o.A},42124:(t,i,e)=>{e.d(i,{A:()=>n});const n="#version 300 es\n#define SHADER_NAME scatterplot-layer-fragment-shader\nprecision highp float;\nin vec4 vFillColor;\nin vec4 vLineColor;\nin vec2 unitPosition;\nin float innerUnitRadius;\nin float outerRadiusPixels;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = unitPosition;\nfloat distToCenter = length(unitPosition) * outerRadiusPixels;\nfloat inCircle = scatterplot.antialiasing ?\nsmoothedge(distToCenter, outerRadiusPixels) :\nstep(distToCenter, outerRadiusPixels);\nif (inCircle == 0.0) {\ndiscard;\n}\nif (scatterplot.stroked > 0.5) {\nfloat isLine = scatterplot.antialiasing ?\nsmoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\nstep(innerUnitRadius * outerRadiusPixels, distToCenter);\nif (scatterplot.filled > 0.5) {\nfragColor = mix(vFillColor, vLineColor, isLine);\n} else {\nif (isLine == 0.0) {\ndiscard;\n}\nfragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n}\n} else if (scatterplot.filled < 0.5) {\ndiscard;\n} else {\nfragColor = vFillColor;\n}\nfragColor.a *= inCircle;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n"},53374:(t,i,e)=>{e.d(i,{A:()=>a});var n=e(17393),o=e(95896),s=e(54024);class r extends n.A{constructor(t={}){super(t)}getViewportType(){return o.A}get ControllerType(){return s.A}}r.displayName="OrthographicView";const a=r},53714:(t,i,e)=>{e.d(i,{A:()=>n});const n="#version 300 es\n#define SHADER_NAME scatterplot-layer-vertex-shader\nin vec3 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin float instanceRadius;\nin float instanceLineWidths;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\nout vec4 vFillColor;\nout vec4 vLineColor;\nout vec2 unitPosition;\nout float innerUnitRadius;\nout float outerRadiusPixels;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\nouterRadiusPixels = clamp(\nproject_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),\nscatterplot.radiusMinPixels, scatterplot.radiusMaxPixels\n);\nfloat lineWidthPixels = clamp(\nproject_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),\nscatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels\n);\nouterRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;\nfloat edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\nunitPosition = edgePadding * positions.xy;\ngeometry.uv = unitPosition;\ngeometry.pickingColor = instancePickingColors;\ninnerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;\nif (scatterplot.billboard) {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = edgePadding * positions * outerRadiusPixels;\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vFillColor, geometry);\nvLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n"},54024:(t,i,e)=>{e.d(i,{A:()=>l});var n=e(54901),o=e(94717),s=e(27698),r=e(70053);class a extends s.c{constructor(t){super(t),this.zoomAxis=t.zoomAxis||"all"}_calculateNewZoom({scale:t,startZoom:i}){const{maxZoom:e,minZoom:o}=this.getViewportProps();void 0===i&&(i=this.getViewportProps().zoom);let s=Math.log2(t);if(Array.isArray(i)){let[t,r]=i;switch(this.zoomAxis){case"X":t=(0,n.qE)(t+s,o,e);break;case"Y":r=(0,n.qE)(r+s,o,e);break;default:let i=Math.min(t+s,r+s);i<o&&(s+=o-i),i=Math.max(t+s,r+s),i>e&&(s+=e-i),t+=s,r+=s}return[t,r]}return(0,n.qE)(i+s,o,e)}}class l extends o.A{constructor(){super(...arguments),this.ControllerState=a,this.transition={transitionDuration:300,transitionInterpolator:new r.A(["target","zoom"])},this.dragMode="pan"}_onPanRotate(){return!1}}},64409:(t,i,e)=>{e.d(i,{F:()=>o});const n="uniform scatterplotUniforms {\n  float radiusScale;\n  float radiusMinPixels;\n  float radiusMaxPixels;\n  float lineWidthScale;\n  float lineWidthMinPixels;\n  float lineWidthMaxPixels;\n  float stroked;\n  float filled;\n  bool antialiasing;\n  bool billboard;\n  highp int radiusUnits;\n  highp int lineWidthUnits;\n} scatterplot;\n",o={name:"scatterplot",vs:n,fs:n,source:"",uniformTypes:{radiusScale:"f32",radiusMinPixels:"f32",radiusMaxPixels:"f32",lineWidthScale:"f32",lineWidthMinPixels:"f32",lineWidthMaxPixels:"f32",stroked:"f32",filled:"f32",antialiasing:"f32",billboard:"f32",radiusUnits:"i32",lineWidthUnits:"i32"}}},95896:(t,i,e)=>{e.d(i,{A:()=>d});var n=e(47345),o=e(31886),s=e(54901),r=e(83588),a=e(73279);const l=(new o.k).lookAt({eye:[0,0,1]});function c({width:t,height:i,near:e,far:n,padding:r}){let a=-t/2,l=t/2,c=-i/2,d=i/2;if(r){const{left:e=0,right:n=0,top:o=0,bottom:p=0}=r,u=(0,s.qE)((e+t-n)/2,0,t)-t/2,g=(0,s.qE)((o+i-p)/2,0,i)-i/2;a-=u,l-=u,c+=g,d+=g}return(new o.k).ortho({left:a,right:l,bottom:c,top:d,near:e,far:n})}class d extends n.A{constructor(t){const{width:i,height:e,near:n=.1,far:o=1e3,zoom:s=0,target:r=[0,0,0],padding:a=null,flipY:d=!0}=t,p=Array.isArray(s)?s[0]:s,u=Array.isArray(s)?s[1]:s,g=Math.min(p,u),h=Math.pow(2,g);let f;if(p!==u){const t=Math.pow(2,p),i=Math.pow(2,u);f={unitsPerMeter:[t/h,i/h,1],metersPerUnit:[h/t,h/i,1]}}super({...t,longitude:void 0,position:r,viewMatrix:l.clone().scale([h,h*(d?-1:1),h]),projectionMatrix:c({width:i||1,height:e||1,padding:a,near:n,far:o}),zoom:g,distanceScales:f})}projectFlat([t,i]){const{unitsPerMeter:e}=this.distanceScales;return[t*e[0],i*e[1]]}unprojectFlat([t,i]){const{metersPerUnit:e}=this.distanceScales;return[t*e[0],i*e[1]]}panByPosition(t,i){const e=(0,a.xJ)(i,this.pixelUnprojectionMatrix),n=this.projectFlat(t),o=r.WQ([],n,r.ze([],e)),s=r.WQ([],this.center,o);return{target:this.unprojectFlat(s)}}}},98543:(t,i,e)=>{e.d(i,{A:()=>v});var n=e(9350),o=e(46487),s=e(84175),r=e(83895),a=e(67118),l=e(33027),c=e(25337),d=e(64409),p=e(53714),u=e(42124),g=e(12228);const h=[0,0,0,255],f={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:t=>t.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:h},getLineColor:{type:"accessor",value:h},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class m extends a.A{getShaders(){return super.getShaders({vs:p.A,fs:u.A,source:g.A,modules:[s.A,o.A,r.A,d.F]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(t){super.updateState(t),t.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:t}){const{radiusUnits:i,radiusScale:e,radiusMinPixels:o,radiusMaxPixels:s,stroked:r,filled:a,billboard:l,antialiasing:c,lineWidthUnits:d,lineWidthScale:p,lineWidthMinPixels:u,lineWidthMaxPixels:g}=this.props,h={stroked:r,filled:a,billboard:l,antialiasing:c,radiusUnits:n.p5[i],radiusScale:e,radiusMinPixels:o,radiusMaxPixels:s,lineWidthUnits:n.p5[d],lineWidthScale:p,lineWidthMinPixels:u,lineWidthMaxPixels:g},f=this.state.model;f.shaderInputs.setProps({scatterplot:h}),"webgpu"===this.context.device.type&&(f.instanceCount=this.props.data.length),f.draw(this.context.renderPass)}_getModel(){const t="webgpu"===this.context.device.type?{depthWriteEnabled:!0,depthCompare:"less-equal"}:void 0;return new l.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new c.V({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,-1,1,0,1,1,0])}}}),isInstanced:!0,parameters:t})}}m.defaultProps=f,m.layerName="ScatterplotLayer";const v=m}}]);