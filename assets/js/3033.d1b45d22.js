"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[3033],{1338:(e,t,o)=>{o.d(t,{w:()=>a});var s=o(7522),i=o(9439),n=o(8846);const a={name:"phongMaterial",dependencies:[s.x],source:i.X,vs:n.X,fs:n.l,defines:{LIGHTING_FRAGMENT:!0},uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(e){const t={...e};return t.specularColor&&(t.specularColor=t.specularColor.map(e=>e/255)),{...a.defaultUniforms,...t}}}},8643:(e,t,o)=>{o.d(t,{A:()=>T});var s=o(3459),i=o(2146),n=o(4175),a=o(3349),r=o(698),l=o(5337),c=o(4947),p=o(1338),d=o(3439),h=o(9350);const g=Math.PI/180,m=new Float32Array(16),u=new Float32Array(12);function f(e,t,o){const s=t[0]*g,i=t[1]*g,n=t[2]*g,a=Math.sin(n),r=Math.sin(s),l=Math.sin(i),c=Math.cos(n),p=Math.cos(s),d=Math.cos(i),h=o[0],m=o[1],u=o[2];e[0]=h*d*p,e[1]=h*l*p,e[2]=h*-r,e[3]=m*(-l*c+d*r*a),e[4]=m*(d*c+l*r*a),e[5]=m*p*a,e[6]=u*(l*a+d*r*c),e[7]=u*(-d*a+l*r*c),e[8]=u*p*c}function y(e){return e[0]=e[0],e[1]=e[1],e[2]=e[2],e[3]=e[4],e[4]=e[5],e[5]=e[6],e[6]=e[8],e[7]=e[9],e[8]=e[10],e[9]=e[12],e[10]=e[13],e[11]=e[14],e.subarray(0,12)}const v={size:12,accessor:["getOrientation","getScale","getTranslation","getTransformMatrix"],shaderAttributes:{instanceModelMatrixCol0:{size:3,elementOffset:0},instanceModelMatrixCol1:{size:3,elementOffset:3},instanceModelMatrixCol2:{size:3,elementOffset:6},instanceTranslation:{size:3,elementOffset:9}},update(e,{startRow:t,endRow:o}){const{data:s,getOrientation:i,getScale:n,getTranslation:a,getTransformMatrix:r}=this.props,l=Array.isArray(r),c=l&&16===r.length,p=Array.isArray(n),h=Array.isArray(i),g=Array.isArray(a),v=c||!l&&Boolean(r(s[0]));e.constant=v?c:h&&p&&g;const x=e.value;if(e.constant){let t;if(v)m.set(r),t=y(m);else{t=u;f(t,i,n),t.set(a,9)}e.value=new Float32Array(t)}else{let l=t*e.size;const{iterable:C,objectInfo:M}=(0,d.X)(s,t,o);for(const e of C){let t;if(M.index++,v)m.set(c?r:r(e,M)),t=y(m);else{t=u;f(t,h?i:i(e,M),p?n:n(e,M)),t.set(g?a:a(e,M),9)}x[l++]=t[0],x[l++]=t[1],x[l++]=t[2],x[l++]=t[3],x[l++]=t[4],x[l++]=t[5],x[l++]=t[6],x[l++]=t[7],x[l++]=t[8],x[l++]=t[9],x[l++]=t[10],x[l++]=t[11]}}}};function x(e,t){return t===h.rf.CARTESIAN||t===h.rf.METER_OFFSETS||t===h.rf.DEFAULT&&!e.isGeospatial}const C="uniform simpleMeshUniforms {\n  float sizeScale;\n  bool composeModelMatrix;\n  bool hasTexture;\n  bool flatShading;\n} simpleMesh;\n",M={name:"simpleMesh",vs:C,fs:C,uniformTypes:{sizeScale:"f32",composeModelMatrix:"f32",hasTexture:"f32",flatShading:"f32"}};function _(e){const t=e.positions||e.POSITION;s.A.assert(t,'no "postions" or "POSITION" attribute in mesh');const o=t.value.length/t.size;let i=e.COLOR_0||e.colors;i||(i={size:3,value:new Float32Array(3*o).fill(1)});let n=e.NORMAL||e.normals;n||(n={size:3,value:new Float32Array(3*o).fill(0)});let a=e.TEXCOORD_0||e.texCoords;return a||(a={size:2,value:new Float32Array(2*o).fill(0)}),{positions:t,colors:i,normals:n,texCoords:a}}function S(e){return e instanceof l.V?(e.attributes=_(e.attributes),e):e.attributes?new l.V({...e,topology:"triangle-list",attributes:_(e.attributes)}):new l.V({topology:"triangle-list",attributes:_(e)})}const P={mesh:{type:"object",value:null,async:!0},texture:{type:"image",value:null,async:!0},sizeScale:{type:"number",value:1,min:0},_instanced:!0,wireframe:!1,material:!0,getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:[0,0,0,255]},getOrientation:{type:"accessor",value:[0,0,0]},getScale:{type:"accessor",value:[1,1,1]},getTranslation:{type:"accessor",value:[0,0,0]},getTransformMatrix:{type:"accessor",value:[]},textureParameters:{type:"object",ignore:!0,value:null}};class L extends i.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\ngeometry.uv = texCoords;\ngeometry.pickingColor = instancePickingColors;\nvTexCoord = texCoords;\ncameraPosition = project.cameraPosition;\nvColor = vec4(colors * instanceColors.rgb, instanceColors.a);\nmat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\nvec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;\nif (simpleMesh.composeModelMatrix) {\nDECKGL_FILTER_SIZE(pos, geometry);\nnormals_commonspace = project_normal(instanceModelMatrix * normals);\ngeometry.worldPosition += pos;\ngl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\ngeometry.position = position_commonspace;\n}\nelse {\npos = project_size(pos);\nDECKGL_FILTER_SIZE(pos, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\ngeometry.position = position_commonspace;\nnormals_commonspace = project_normal(instanceModelMatrix * normals);\n}\ngeometry.normal = normals_commonspace;\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\nprecision highp float;\nuniform sampler2D sampler;\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = vTexCoord;\nvec3 normal;\nif (simpleMesh.flatShading) {\nnormal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n} else {\nnormal = normals_commonspace;\n}\nvec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;\nDECKGL_FILTER_COLOR(color, geometry);\nvec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\nfragColor = vec4(lightColor, color.a * layer.opacity);\n}\n",modules:[n.A,p.w,a.A,M]})}getBounds(){if(this.props._instanced)return super.getBounds();let e=this.state.positionBounds;if(e)return e;const{mesh:t}=this.props;if(!t)return null;if(e=t.header?.boundingBox,!e){const{attributes:o}=S(t);o.POSITION=o.POSITION||o.positions,e=function(e){let t=1/0,o=1/0,s=1/0,i=-1/0,n=-1/0,a=-1/0;const r=e.POSITION?e.POSITION.value:[],l=r&&r.length;for(let c=0;c<l;c+=3){const e=r[c],l=r[c+1],p=r[c+2];t=e<t?e:t,o=l<o?l:o,s=p<s?p:s,i=e>i?e:i,n=l>n?l:n,a=p>a?p:a}return[[t,o,s],[i,n,a]]}(o)}return this.state.positionBounds=e,e}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{transition:!0,type:"float64",fp64:this.use64bitPositions(),size:3,accessor:"getPosition"},instanceColors:{type:"unorm8",transition:!0,size:this.props.colorFormat.length,accessor:"getColor",defaultValue:[0,0,0,255]},instanceModelMatrix:v}),this.setState({emptyTexture:this.context.device.createTexture({data:new Uint8Array(4),width:1,height:1})})}updateState(e){super.updateState(e);const{props:t,oldProps:o,changeFlags:s}=e;if(t.mesh!==o.mesh||s.extensionsChanged){if(this.state.positionBounds=null,this.state.model?.destroy(),t.mesh){this.state.model=this.getModel(t.mesh);const e=t.mesh.attributes||t.mesh;this.setState({hasNormals:Boolean(e.NORMAL||e.normals)})}this.getAttributeManager().invalidateAll()}t.texture!==o.texture&&t.texture instanceof r.g&&this.setTexture(t.texture),this.state.model&&this.state.model.setTopology(this.props.wireframe?"line-strip":"triangle-list")}finalizeState(e){super.finalizeState(e),this.state.emptyTexture.delete()}draw({uniforms:e}){const{model:t}=this.state;if(!t)return;const{viewport:o,renderPass:s}=this.context,{sizeScale:i,coordinateSystem:n,_instanced:a}=this.props,r={sizeScale:i,composeModelMatrix:!a||x(o,n),flatShading:!this.state.hasNormals};t.shaderInputs.setProps({simpleMesh:r}),t.draw(s)}get isLoaded(){return Boolean(this.state?.model&&super.isLoaded)}getModel(e){const t=new c.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:S(e),isInstanced:!0}),{texture:o}=this.props,{emptyTexture:s}=this.state,i={sampler:o||s,hasTexture:Boolean(o)};return t.shaderInputs.setProps({simpleMesh:i}),t}setTexture(e){const{emptyTexture:t,model:o}=this.state;if(o){const s={sampler:e||t,hasTexture:Boolean(e)};o.shaderInputs.setProps({simpleMesh:s})}}}L.defaultProps=P,L.layerName="SimpleMeshLayer";const T=L},9751:(e,t,o)=>{o.d(t,{A:()=>g});var s=o(9452),i=o(3459),n=o(3439),a=o(1105),r=o(4968),l=o(812),c=o(6053);const p=[0,0,0,255],d={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:e=>e.polygon},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:p},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0};class h extends s.A{initializeState(){this.state={paths:[],pathsDiff:null},this.props.getLineDashArray&&i.A.removed("getLineDashArray","PathStyleExtension")()}updateState({changeFlags:e}){const t=e.dataChanged||e.updateTriggersChanged&&(e.updateTriggersChanged.all||e.updateTriggersChanged.getPolygon);if(t&&Array.isArray(e.dataChanged)){const t=this.state.paths.slice(),o=e.dataChanged.map(e=>(0,c.J)({data:t,getIndex:e=>e.__source.index,dataRange:e,replace:this._getPaths(e)}));this.setState({paths:t,pathsDiff:o})}else t&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(e={}){const{data:t,getPolygon:o,positionFormat:s,_normalize:i}=this.props,a=[],r="XY"===s?2:3,{startRow:c,endRow:p}=e,{iterable:d,objectInfo:h}=(0,n.X)(t,c,p);for(const n of d){h.index++;let e=o(n,h);i&&(e=l.S8(e,r));const{holeIndices:t}=e,s=e.positions||e;if(t)for(let o=0;o<=t.length;o++){const e=s.slice(t[o-1]||0,t[o]||s.length);a.push(this.getSubLayerRow({path:e},n,h.index))}else a.push(this.getSubLayerRow({path:s},n,h.index))}return a}renderLayers(){const{data:e,_dataDiff:t,stroked:o,filled:s,extruded:i,wireframe:n,_normalize:l,_windingOrder:c,elevationScale:d,transitions:h,positionFormat:g}=this.props,{lineWidthUnits:m,lineWidthScale:u,lineWidthMinPixels:f,lineWidthMaxPixels:y,lineJointRounded:v,lineMiterLimit:x,lineDashJustified:C}=this.props,{getFillColor:M,getLineColor:_,getLineWidth:S,getLineDashArray:P,getElevation:L,getPolygon:T,updateTriggers:A,material:b}=this.props,{paths:w,pathsDiff:I}=this.state,O=this.getSubLayerClass("fill",a.A),E=this.getSubLayerClass("stroke",r.A),z=this.shouldRenderSubLayer("fill",w)&&new O({_dataDiff:t,extruded:i,elevationScale:d,filled:s,wireframe:n,_normalize:l,_windingOrder:c,getElevation:L,getFillColor:M,getLineColor:i&&n?_:p,material:b,transitions:h},this.getSubLayerProps({id:"fill",updateTriggers:A&&{getPolygon:A.getPolygon,getElevation:A.getElevation,getFillColor:A.getFillColor,lineColors:i&&n,getLineColor:A.getLineColor}}),{data:e,positionFormat:g,getPolygon:T});return[!i&&z,!i&&o&&this.shouldRenderSubLayer("stroke",w)&&new E({_dataDiff:I&&(()=>I),widthUnits:m,widthScale:u,widthMinPixels:f,widthMaxPixels:y,jointRounded:v,miterLimit:x,dashJustified:C,_pathType:"loop",transitions:h&&{getWidth:h.getLineWidth,getColor:h.getLineColor,getPath:h.getPolygon},getColor:this.getSubLayerAccessor(_),getWidth:this.getSubLayerAccessor(S),getDashArray:this.getSubLayerAccessor(P)},this.getSubLayerProps({id:"stroke",updateTriggers:A&&{getWidth:A.getLineWidth,getColor:A.getLineColor,getDashArray:A.getLineDashArray}}),{data:w,positionFormat:g,getPath:e=>e.path}),i&&z]}}h.layerName="PolygonLayer",h.defaultProps=d;const g=h}}]);