"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[6094],{6231:(e,t,n)=>{n.d(t,{A:()=>h});var i=n(2146),o=n(4175),s=n(3349),r=n(9350),a=n(5337),c=n(1904);const l="uniform lineUniforms {\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  float useShortestPath;\n  highp int widthUnits;\n} line;\n",d={name:"line",vs:l,fs:l,uniformTypes:{widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",useShortestPath:"f32",widthUnits:"i32"}},u={getSourcePosition:{type:"accessor",value:e=>e.sourcePosition},getTargetPosition:{type:"accessor",value:e=>e.targetPosition},getColor:{type:"accessor",value:[0,0,0,255]},getWidth:{type:"accessor",value:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class p extends i.A{getBounds(){return this.getAttributeManager()?.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME line-layer-vertex-shader\nin vec3 positions;\nin vec3 instanceSourcePositions;\nin vec3 instanceTargetPositions;\nin vec3 instanceSourcePositions64Low;\nin vec3 instanceTargetPositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin float instanceWidths;\nout vec4 vColor;\nout vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\nvec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);\ndir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\nreturn dir_screenspace * offset_direction * width / 2.0;\n}\nvec3 splitLine(vec3 a, vec3 b, float x) {\nfloat t = (x - a.x) / (b.x - a.x);\nreturn vec3(x, mix(a.yz, b.yz, t));\n}\nvoid main(void) {\ngeometry.worldPosition = instanceSourcePositions;\ngeometry.worldPositionAlt = instanceTargetPositions;\nvec3 source_world = instanceSourcePositions;\nvec3 target_world = instanceTargetPositions;\nvec3 source_world_64low = instanceSourcePositions64Low;\nvec3 target_world_64low = instanceTargetPositions64Low;\nif (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {\nsource_world.x = mod(source_world.x + 180., 360.0) - 180.;\ntarget_world.x = mod(target_world.x + 180., 360.0) - 180.;\nfloat deltaLng = target_world.x - source_world.x;\nif (deltaLng * line.useShortestPath > 180.) {\nsource_world.x += 360. * line.useShortestPath;\nsource_world = splitLine(source_world, target_world, 180. * line.useShortestPath);\nsource_world_64low = vec3(0.0);\n} else if (deltaLng * line.useShortestPath < -180.) {\ntarget_world.x += 360. * line.useShortestPath;\ntarget_world = splitLine(source_world, target_world, 180. * line.useShortestPath);\ntarget_world_64low = vec3(0.0);\n} else if (line.useShortestPath < 0.) {\ngl_Position = vec4(0.);\nreturn;\n}\n}\nvec4 source_commonspace;\nvec4 target_commonspace;\nvec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\nvec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\nfloat segmentIndex = positions.x;\nvec4 p = mix(source, target, segmentIndex);\ngeometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\nuv = positions.xy;\ngeometry.uv = uv;\ngeometry.pickingColor = instancePickingColors;\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),\nline.widthMinPixels, line.widthMaxPixels\n);\nvec3 offset = vec3(\ngetExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\nDECKGL_FILTER_GL_POSITION(p, geometry);\ngl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\nvColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME line-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 uv;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = uv;\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[o.A,s.A,d]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:[0,0,0,255]},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1}})}updateState(e){super.updateState(e),e.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:e}){const{widthUnits:t,widthScale:n,widthMinPixels:i,widthMaxPixels:o,wrapLongitude:s}=this.props,a=this.state.model,c={widthUnits:r.p5[t],widthScale:n,widthMinPixels:i,widthMaxPixels:o,useShortestPath:s?1:0};a.shaderInputs.setProps({line:c}),a.draw(this.context.renderPass),s&&(a.shaderInputs.setProps({line:{...c,useShortestPath:-1}}),a.draw(this.context.renderPass))}_getModel(){return new c.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new a.V({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array([0,-1,0,0,1,0,1,-1,0,1,1,0])}}}),isInstanced:!0})}}p.layerName="LineLayer",p.defaultProps=u;const h=p},840:(e,t,n)=>{n.d(t,{A:()=>v});var i=n(6540),o=n(1862);const s="undefined"!=typeof window?i.useLayoutEffect:i.useEffect;function r(e,t){for(;e;){if(e===t)return!0;e=Object.getPrototypeOf(e)}return!1}var a=n(1152),c=n(2146);const l={position:"absolute",zIndex:-1};function d(e,t){if("function"==typeof e)return e(t);if(Array.isArray(e))return e.map((e=>d(e,t)));if(u(e)){if(n=e,n.props?.mapStyle)return t.style=l,(0,i.cloneElement)(e,t);if(function(e){const t=e.type;return t&&t.deckGLViewProps}(e))return(0,i.cloneElement)(e,t)}var n;return e}function u(e){return e&&"object"==typeof e&&"type"in e||!1}function p(e){if("function"==typeof e)return(0,i.createElement)(a.A,{},e);if(Array.isArray(e))return e.map(p);if(u(e)){if(e.type===i.Fragment)return p(e.props.children);if(r(e.type,a.A))return e}return e}const h=(0,i.createContext)();const w={mixBlendMode:null};function f(e){e.redrawReason&&(e.deck._drawLayers(e.redrawReason),e.redrawReason=null)}const g=i.forwardRef((function(e,t){const[n,l]=(0,i.useState)(0),g=(0,i.useRef)({control:null,version:n,forceUpdate:()=>l((e=>e+1))}).current,v=(0,i.useRef)(null),y=(0,i.useRef)(null),_=(0,i.useMemo)((()=>function({children:e,layers:t=[],views:n=null}){const o=[],s=[],l={};return i.Children.forEach(p(e),(e=>{if(u(e)){const t=e.type;if(r(t,c.A)){const n=function(e,t){const n={},i=e.defaultProps||{};for(const o in t)i[o]!==t[o]&&(n[o]=t[o]);return new e(n)}(t,e.props);s.push(n)}else o.push(e);if(r(t,a.A)&&t!==a.A&&e.props.id){const n=new t(e.props);l[n.id]=n}}else e&&o.push(e)})),Object.keys(l).length>0&&(Array.isArray(n)?n.forEach((e=>{l[e.id]=e})):n&&(l[n.id]=n),n=Object.values(l)),{layers:t=s.length>0?[...s,...t]:t,children:o,views:n}}(e)),[e.layers,e.views,e.children]);let m=!0;const P=t=>m&&e.viewState?(g.viewStateUpdateRequested=t,null):(g.viewStateUpdateRequested=null,e.onViewStateChange?.(t)),x=t=>{m?g.interactionStateUpdateRequested=t:(g.interactionStateUpdateRequested=null,e.onInteractionStateChange?.(t))},S=(0,i.useMemo)((()=>{const t={widgets:[],...e,style:null,width:"100%",height:"100%",parent:v.current,canvas:y.current,layers:_.layers,views:_.views,onViewStateChange:P,onInteractionStateChange:x};return delete t._customRender,g.deck&&g.deck.setProps(t),t}),[e]);(0,i.useEffect)((()=>{const t=e.Deck||o.A;return g.deck=function(e,t,n){const i=new t({...n,_customRender:t=>{e.redrawReason=t;const n=i.getViewports();e.lastRenderedViewports!==n?e.forceUpdate():f(e)}});return i}(g,t,{...S,parent:v.current,canvas:y.current}),()=>g.deck?.finalize()}),[]),s((()=>{f(g);const{viewStateUpdateRequested:e,interactionStateUpdateRequested:t}=g;e&&P(e),t&&x(t)})),(0,i.useImperativeHandle)(t,(()=>function(e){return{get deck(){return e.deck},pickObject:t=>e.deck.pickObject(t),pickMultipleObjects:t=>e.deck.pickMultipleObjects(t),pickObjects:t=>e.deck.pickObjects(t)}}(g)),[]);const k=g.deck&&g.deck.isInitialized?g.deck.getViewports():void 0,{ContextProvider:C,width:b="100%",height:A="100%",id:E,style:L}=e,{containerStyle:M,canvasStyle:R}=(0,i.useMemo)((()=>function({width:e,height:t,style:n}){const i={position:"absolute",zIndex:0,left:0,top:0,width:e,height:t},o={left:0,top:0};if(n)for(const s in n)s in w?o[s]=n[s]:i[s]=n[s];return{containerStyle:i,canvasStyle:o}}({width:b,height:A,style:L})),[b,A,L]);if(!g.viewStateUpdateRequested&&g.lastRenderedViewports===k||g.version!==n){g.lastRenderedViewports=k,g.version=n;const e=function({children:e,deck:t,ContextProvider:n=h.Provider}){const{viewManager:o}=t||{};if(!o||!o.views.length)return[];const s={},c=o.views[0].id;for(const i of e){let e=c,t=i;u(i)&&r(i.type,a.A)&&(e=i.props.id||c,t=i.props.children);const n=o.getViewport(e),l=o.getViewState(e);if(n){l.padding=n.padding;const{x:i,y:o,width:r,height:a}=n;t=d(t,{x:i,y:o,width:r,height:a,viewport:n,viewState:l}),s[e]||(s[e]={viewport:n,children:[]}),s[e].children.push(t)}}return Object.keys(s).map((e=>{const{viewport:o,children:r}=s[e],{x:a,y:c,width:l,height:d}=o,u={position:"absolute",left:a,top:c,width:l,height:d},p=`view-${e}`,h=(0,i.createElement)("div",{key:p,id:p,style:u},...r),w={deck:t,viewport:o,container:t.canvas.offsetParent,eventManager:t.eventManager,onViewStateChange:n=>{n.viewId=e,t._onViewStateChange(n)},widgets:[]},f=`view-${e}-context`;return(0,i.createElement)(n,{key:f,value:w},h)}))}({children:_.children,deck:g.deck,ContextProvider:C}),t=(0,i.createElement)("canvas",{key:"canvas",id:E||"deckgl-overlay",ref:y,style:R});g.control=(0,i.createElement)("div",{id:`${E||"deckgl"}-wrapper`,ref:v,style:M},[t,e])}return m=!1,g.control})),v=g}}]);