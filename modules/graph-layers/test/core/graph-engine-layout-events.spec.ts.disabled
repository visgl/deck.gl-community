// deck.gl-community
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors

import {describe, it, expect} from 'vitest';

import type {Bounds2D} from '@math.gl/types';

import {GraphEngine} from '../../src/core/graph-engine';
import type {GraphLayoutEventDetail} from '../../src/core/graph-layout';
import {LegacyGraph} from '../../src/graph/legacy-graph';
import {Node} from '../../src/graph/node';
import {HivePlotLayout} from '../../src/layouts/experimental/hive-plot-layout';
import {RadialLayout} from '../../src/layouts/experimental/radial-layout';

type CapturedEvent = {
  type: 'start' | 'change' | 'done';
  bounds?: Bounds2D | null;
};

function recordEngineEvents(engine: GraphEngine): CapturedEvent[] {
  const events: CapturedEvent[] = [];
  const handler = (type: CapturedEvent['type']) => (detail?: GraphLayoutEventDetail) => {
    events.push({type, bounds: detail?.bounds ?? null});
  };

  const previousCallbacks = engine.props.callbacks ?? {};
  engine.setProps({
    callbacks: {
      ...previousCallbacks,
      onLayoutStart: (detail) => {
        handler('start')(detail);
        previousCallbacks.onLayoutStart?.(detail);
      },
      onLayoutChange: (detail) => {
        handler('change')(detail);
        previousCallbacks.onLayoutChange?.(detail);
      },
      onLayoutDone: (detail) => {
        handler('done')(detail);
        previousCallbacks.onLayoutDone?.(detail);
      }
    }
  });

  return events;
}

describe('GraphEngine layout lifecycle events', () => {
  it('emits start/change/done in order for HivePlotLayout', () => {
    const nodes = [
      new Node({id: 'a', data: {group: 0}}),
      new Node({id: 'b', data: {group: 1}}),
      new Node({id: 'c', data: {group: 0}})
    ];
    const graph = new LegacyGraph({nodes});
    const layout = new HivePlotLayout();
    const engine = new GraphEngine({graph, layout});

    const events = recordEngineEvents(engine);

    engine.run();

    expect(events.map((event) => event.type)).toEqual(['start', 'change', 'done']);
    expect(events[0]?.bounds).not.toBeNull();
    expect(events[1]?.bounds).toEqual(events[2]?.bounds);
    expect(events[2]?.bounds).toEqual(layout.getBounds());
  });

  it('emits start/change/done in order for RadialLayout', () => {
    const nodes = ['root', 'child-1', 'child-2', 'leaf-1', 'leaf-2'].map((id) => new Node({id}));
    const graph = new LegacyGraph({nodes});
    const layout = new RadialLayout({
      tree: [
        {id: 'root', children: ['child-1', 'child-2']},
        {id: 'child-1', children: ['leaf-1']},
        {id: 'child-2', children: ['leaf-2']},
        {id: 'leaf-1', children: []},
        {id: 'leaf-2', children: []}
      ]
    });
    const engine = new GraphEngine({graph, layout});

    const events = recordEngineEvents(engine);

    engine.run();

    expect(events.map((event) => event.type)).toEqual(['start', 'change', 'done']);
    expect(events[0]?.bounds).toBeNull();
    expect(events[1]?.bounds).toEqual(events[2]?.bounds);
    expect(events[2]?.bounds).toEqual(layout.getBounds());
  });
});
